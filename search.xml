<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>QT学习笔记</title>
      <link href="/2025/01/13/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/01/13/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="C-重要语法"><a href="#C-重要语法" class="headerlink" title="C++重要语法"></a>C++重要语法</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p><code>std</code> 是C++的标准命名空间，它是一个定义在 C++ 标准库中的所有类、函数和变量的命名空间。使用方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>自定义命名空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cir &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">double</span> PI = <span class="number">3.145926</span>;</span><br><span class="line">    <span class="comment">/*获取周长*/</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get_L</span><span class="params">(<span class="type">double</span> R)</span></span>;</span><br><span class="line">    <span class="comment">/*获取面积*/</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get_S</span><span class="params">(<span class="type">double</span> R)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中在 C++ 中，如果你想在命名空间内定义一个常量（如 <code>PI</code>），通常需要使用 <code>const</code> 关键字或者将其定义为 <code>constexpr</code>（C++11 及以上版本）。直接使用 <code>double PI = 3.14;</code> 在命名空间中是不合法的，因为命名空间不支持直接初始化变量。你需要使用 <code>const</code> 或 <code>constexpr</code>。</p><p>接下载需要具体化函数内容有两种写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cir.h&quot;</span></span></span><br><span class="line"><span class="comment">/*写法1*/</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cir::get_L</span><span class="params">(<span class="type">double</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> R*<span class="number">2</span>*cir::PI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cir::get_S</span><span class="params">(<span class="type">double</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> R*R*cir::PI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*写法2*/</span></span><br><span class="line"><span class="keyword">namespace</span> cir &#123;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get_L</span><span class="params">(<span class="type">double</span> R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> R*<span class="number">2</span>*cir::PI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get_S</span><span class="params">(<span class="type">double</span> R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> R*R*cir::PI;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>std包含的内容</strong></p><p><code>std</code>命名空间包含了许多类、函数和对象，例如：</p><ul><li><p>输入输出库（如<code>std::cout , std::cin , std::endl</code>）</p></li><li><p>容器类（如<code>std::vector , std::map , std::set</code>）</p></li><li><p>字符串类（<code>std::string</code>）</p></li><li><p>异常类（<code>std::exception</code>和相关子类）</p></li><li><p>算法（如<code>std::sort , std::find</code>）</p></li><li><p>实用工具（如<code>std::pair , std::tuple</code>）</p></li><li><p>其他许多功能</p></li></ul><p><strong>使用建议</strong></p><p>对于小型代码或示例代码，使用<code>using namespace std;</code> 通常是安全的。对于大型项目或库，建议显式地使用<code>std::</code> 前缀，以避免潜在的名称冲突，并提高代码的可读性和可维护性。<code>std</code>命名空间是 C++ 编程的基础部分，理解和正确使用它对于编写健壮和高效的 C++ 代码至关重要。</p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>C++ 中的输入和输出(I&#x2F;O)主要是通过标准库中的输入输出流来实现的。最常用的是<code>iostream</code>库，它</p><p>提供了用于输入和输出的基本流类，包括<code>cin</code>、<code>cout</code>、<code>cerr</code>和<code>clog</code>。</p><p>基本使用输出流如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; <span class="string">&quot;woeld&quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输入(箭头指向数据的方向)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cin &gt;&gt; i;</span><br></pre></td></tr></table></figure><p><strong>标准错误流</strong> <strong>(</strong><code>cerr</code>) <strong>和标准日志流</strong> <strong>(</strong> <code>clog</code>)</p><p><code>cerr</code>用于输出错误消息。与<code>cout</code>不同，<code>cerr</code>不是缓冲的，这意味着它会立即输出。</p><p><code>clog</code>类似于<code>cerr</code>，但它是缓冲的。它通常用于记录错误和日志信息。</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>C++中可以直接使用<code>bool</code>类型的数据，包含<code>true</code>,<code>false</code>值。</p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>内联函数（Inline Function）是C++中一种特殊的函数，其定义直接在每个调用点展开。这意味着编译器会将函数调用<strong>替换</strong>为函数本身的代码，这样可以减少函数调用的开销，尤其是在小型函数中。主要作用为提升代码的可读性。<strong>关键字 <code>inline</code> 必须与函数定义体放在一起才能使函数成为内联</strong>。在函数声明处添加 <code>inline</code> 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 <code>inline</code> 关键字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i+j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lambda匿名函数"><a href="#Lambda匿名函数" class="headerlink" title="Lambda匿名函数"></a>Lambda匿名函数</h2><p>Lambda 表达式是 C++11 引入的一种匿名函数的方式，<strong>它允许你在需要函数的地方内联地定义函数，而无需单独命名函数。</strong>相较于普通非匿名函数，匿名函数无需进行另外的声明和定义，仅当调用该匿名时，函数体才会创建，且调用完毕后会立即释放资源。因此匿名函数会更加节省空间，常用于像<code>std::sort</code>这样可以重写排序方式的函数。Lambda表达式基本语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  捕获列表         参数          返回值类型</span></span><br><span class="line">[capture clause](parameters) -&gt; return_type&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">    <span class="comment">//可以使用捕获列表中的参数</span></span><br><span class="line">    <span class="keyword">return</span> expression;<span class="comment">//可选返回语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda 表达式由以下部分组成：</p><ul><li><p><strong>捕获列表（Capture clause</strong>：用于捕获外部变量，在 Lambda 表达式中可以访问这些变量。捕获列表可以为空，也可以包含变量列表<code>[var1, var2, ...]</code>。</p></li><li><p><strong>参数列表（Parameters）</strong>：与普通函数的参数列表类似，可以为空或包含参数列表<code>(param1,param2, ...)</code>。</p></li><li><p><strong>返回类型（Return type）</strong>：Lambda 表达式可以自动推断返回类型auto，也可以显式指定返回类型 -&gt; return_type 。如果函数体只有一条返回语句，可以省略返回类型。</p></li><li><p><strong>函数体（Body）</strong>：Lambda 表达式的函数体，包含需要执行的代码。</p></li></ul><p>匿名函数的使用例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子1：</span></span><br><span class="line"><span class="keyword">auto</span> testReturn = [](<span class="type">int</span> a1, <span class="type">int</span> a2) &#123;<span class="keyword">return</span> a1&gt;a2 &#125;;</span><br><span class="line"><span class="type">bool</span> flag = <span class="built_in">testReturn</span>(<span class="number">23</span>, <span class="number">21</span>);</span><br><span class="line">cout&lt;&lt;flag&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子2：</span></span><br><span class="line"><span class="type">int</span> as = <span class="number">100</span>；</span><br><span class="line"><span class="keyword">auto</span> testReturn = [](<span class="type">int</span> a1, <span class="type">int</span> a2) &#123;<span class="keyword">return</span> a1&gt;a2 &#125;;</span><br><span class="line"><span class="type">bool</span> flag = <span class="built_in">testReturn</span>(as, <span class="number">21</span>);</span><br><span class="line">cout&lt;&lt;flag&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子3：</span></span><br><span class="line"><span class="type">int</span> as = <span class="number">100</span>；</span><br><span class="line"><span class="keyword">auto</span> testReturn = [&amp;](<span class="type">int</span> a1, <span class="type">int</span> a2) &#123;a1 = <span class="number">10</span>； <span class="keyword">return</span> a1&gt;a2 &#125;;</span><br><span class="line"><span class="type">bool</span> flag = <span class="built_in">testReturn</span>(as, <span class="number">21</span>);</span><br><span class="line">cout&lt;&lt;flag&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;as&lt;&lt;endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>重点：</strong>区分<code>auto add = [=](int a1, int a2) &#123;return a1+a2 &#125;;</code>和<code>auto add = [&amp;](int a1, int a2) &#123;return a1+a2 &#125;</code>。其中的区别主要为<code>[=]</code>和<code>[&amp;]</code>,其中<code>[=]</code>表示按<strong>数值</strong>传入上方所用的变量，其中<code>[&amp;]</code>表示按<strong>引用</strong>传入上方所用的变量。按<strong>数值</strong>传入的变量只可以访问不能修改，按<strong>引用</strong>传入的变量可以访问并且修改。</p><p>Lambda还有一个重要的作用就是<strong>把自身当作回调函数的参数</strong>，演示代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_best</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">bool</span> (*compare)(<span class="type">int</span> a, <span class="type">int</span> b))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">compare</span>(a, b))<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">get_best</span>(<span class="number">12</span>, <span class="number">34</span>, [](<span class="type">int</span> a,<span class="type">int</span> b)-&gt;<span class="type">bool</span>&#123;<span class="keyword">if</span>(a&lt;b)<span class="keyword">return</span> <span class="literal">true</span>; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;&#125;) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用该方法可以快速的编写回调函数。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>本地部署AI知识库</title>
      <link href="/2024/12/15/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2AI%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
      <url>/2024/12/15/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2AI%E7%9F%A5%E8%AF%86%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>突发奇想，打算在本机部署chat大语言模型，同时部署embedding模型将文档等数据转化成向量，实现知识库。</p><h1 id="Ollama本地部署模型"><a href="#Ollama本地部署模型" class="headerlink" title="Ollama本地部署模型"></a>Ollama本地部署模型</h1><p><a href="(https://ollama.com/)">Ollama</a> 是一个用于本地部署和运行大型语言模型（LLM）的平台，旨在让开发者和研究人员能够在本地计算机上高效、低延迟地运行和使用人工智能模型。它支持多种预训练的语言模型，并提供了一个简单易用的界面和 API，帮助用户在无需云端依赖的情况下进行自然语言处理、对话生成、文本分析等任务。</p><h2 id="Ollama相关指令"><a href="#Ollama相关指令" class="headerlink" title="Ollama相关指令"></a>Ollama相关指令</h2><p>Ollama 提供了一些常用的命令行操作指令来帮助用户管理模型、启动服务、加载模型等。以下是一些常见的 Ollama 操作指令：</p><h3 id="1-ollama-pull"><a href="#1-ollama-pull" class="headerlink" title="1. ollama pull &lt;model-name&gt;"></a>1. <strong><code>ollama pull &lt;model-name&gt;</code></strong></h3><ul><li><strong>作用</strong>：下载并安装指定的模型。</li><li><strong>示例</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama pull llama-7b</span><br></pre></td></tr></table></figure>该命令会下载名为 <code>llama-7b</code> 的模型到本地。</li></ul><h3 id="2-ollama-list"><a href="#2-ollama-list" class="headerlink" title="2. ollama list"></a>2. <strong><code>ollama list</code></strong></h3><ul><li><strong>作用</strong>：列出当前本地已安装的所有模型。</li><li><strong>示例</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama list</span><br></pre></td></tr></table></figure>该命令会列出你已经下载并安装在本地的模型列表。</li></ul><h3 id="3-ollama-run"><a href="#3-ollama-run" class="headerlink" title="3. ollama run &lt;model-name&gt;"></a>3. <strong><code>ollama run &lt;model-name&gt;</code></strong></h3><ul><li><strong>作用</strong>：直接运行并与指定模型进行交互。</li><li><strong>示例</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run llama-7b</span><br></pre></td></tr></table></figure>该命令会启动一个交互式会话，并与指定的模型进行对话。</li></ul><h3 id="4-ollama-rm"><a href="#4-ollama-rm" class="headerlink" title="4. ollama rm &lt;model-name&gt;"></a>4. <strong><code>ollama rm &lt;model-name&gt;</code></strong></h3><ul><li><strong>作用</strong>：删除指定的本地模型。</li><li><strong>示例</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama <span class="built_in">rm</span> llama-7b</span><br></pre></td></tr></table></figure>该命令会删除名为 <code>llama-7b</code> 的模型，释放本地存储空间。</li></ul><h3 id="5-ollama-serve"><a href="#5-ollama-serve" class="headerlink" title="5. ollama serve"></a>5. <strong><code>ollama serve</code></strong></h3><ul><li><strong>作用</strong>：启动 Ollama 的本地服务，通常用于为外部应用提供 API 接口。</li><li><strong>示例</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama serve</span><br></pre></td></tr></table></figure>启动服务后，Ollama 会在本地启动一个服务器，默认端口可能为 <code>5000</code> 或 <code>11434</code>，你可以通过访问 <code>http://localhost:&lt;port&gt;</code> 与模型进行交互。</li></ul><h3 id="6-ollama-show"><a href="#6-ollama-show" class="headerlink" title="6. ollama show &lt;model-name&gt;"></a>6. <strong><code>ollama show &lt;model-name&gt;</code></strong></h3><ul><li><strong>作用</strong>：查看已安装模型的详细信息，包括模型的版本、参数等。</li><li><strong>示例</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama show llama-7b</span><br></pre></td></tr></table></figure>该命令会显示 <code>llama-7b</code> 模型的详细信息。</li></ul><h3 id="其他命令选项"><a href="#其他命令选项" class="headerlink" title="其他命令选项"></a>其他命令选项</h3><ul><li>**<code>ollama help</code>**：查看所有可用的 Ollama 命令。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama <span class="built_in">help</span></span><br></pre></td></tr></table></figure>该命令会列出所有可用的命令和参数，并显示简要的使用说明。</li></ul><h2 id="Ollama模型推荐"><a href="#Ollama模型推荐" class="headerlink" title="Ollama模型推荐"></a>Ollama模型推荐</h2><p>个人电脑如果配备较好的个人显卡可以尝试<code>7b~32b</code>的模型，<code>70b</code>的模型虽然较为智能<strong>But</strong>速度会非常慢，且需要至少32GB 的显存，不是非常推荐。笔记本用户如果想尝试可以使用<code>llama3.2</code>，其主攻轻量化的场景有<code>1b</code>和<code>3b</code>两个版本可供选择。如果有40系显卡的加持可以尝试<code>7b</code>以上<code>70b</code>以下的模型。</p><p><strong>本人安装模型如下</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME                              ID              SIZE      MODIFIED</span><br><span class="line">qwen2.5:14b                       7cdf5a0187d5    9.0 GB    6 minutes ago</span><br><span class="line">qwen2.5:32b                       9f13ba1299af    19 GB     21 minutes ago</span><br><span class="line">nomic-embed-text:latest           0a109f422b47    274 MB    55 minutes ago</span><br><span class="line">llama3.1:8b                       46e0c10c039e    4.9 GB    55 minutes ago</span><br><span class="line">shaw/dmeta-embedding-zh:latest    55960d8a3a42    408 MB    18 hours ago</span><br></pre></td></tr></table></figure><p>其中<code>nomic-embed-text:latest</code>和<code>shaw/dmeta-embedding-zh:latest</code>为Embedding嵌入模型，其余为Chat模型。<br><strong>Embedding（嵌入）模型</strong>是自然语言处理（NLP）和机器学习中的一个重要概念，它将高维的离散数据（如单词、句子、图片等）转换为低维的、连续的向量表示。通过这种方式，嵌入模型能够将复杂的输入数据转化为机器学习算法可以处理的数值格式，同时保持数据的语义关系和结构。</p><h3 id="Embedding模型的作用"><a href="#Embedding模型的作用" class="headerlink" title="Embedding模型的作用"></a>Embedding模型的作用</h3><ul><li><p><strong>将离散数据转换为连续向量</strong>：许多机器学习模型（如神经网络）不能直接处理离散的非数值数据（如文本、类别标签等）。Embedding 模型通过将这些离散的对象（例如单词、句子或图像）映射到一个连续的向量空间，使它们变得适合于计算机处理。</p></li><li><p><strong>保留语义和上下文信息</strong>：嵌入模型的一个重要特点是能够将语义相似的对象映射到相似的向量位置。举例来说，<strong>Word2Vec</strong> 和 <strong>GloVe</strong> 这样的词嵌入模型会使得“猫”和“狗”在向量空间中的位置靠得很近，因为它们在许多上下文中具有相似的意义。这种特性对于许多下游任务（如语义分析、情感分析等）非常有用。</p></li><li><p><strong>降低维度</strong>：通过将数据从高维空间映射到低维空间，Embedding 模型不仅能减少计算量，还能减少噪声和冗余信息。这对于提高模型的性能和训练效率至关重要，尤其是在处理大规模数据时。</p></li><li><p><strong>提升模型泛化能力</strong>：通过使用嵌入向量，模型可以捕获到更丰富的特征表示，从而提高其泛化能力。例如，通过词嵌入，模型能够理解“跑步”和“运动”之间的关系，而不仅仅是将它们视为完全不同的单词。</p></li></ul><h3 id="Embedding模型的常见类型"><a href="#Embedding模型的常见类型" class="headerlink" title="Embedding模型的常见类型"></a>Embedding模型的常见类型</h3><ul><li><p><strong>Word Embeddings（词嵌入）</strong>：</p><ul><li><strong>Word2Vec</strong>：基于上下文的词嵌入模型，分为两种架构——CBOW（Continuous Bag of Words）和 Skip-gram。</li><li><strong>GloVe</strong>：通过矩阵分解技术生成的词嵌入模型，注重捕捉全局统计信息。</li><li><strong>FastText</strong>：在 Word2Vec 的基础上进一步考虑了词内的子词信息，能够更好地处理未知词汇。</li></ul></li><li><p><strong>Sentence Embeddings（句子嵌入）</strong>：</p><ul><li><strong>Doc2Vec</strong>：是 Word2Vec 的扩展，能够为整个文档（句子、段落等）生成一个固定的向量表示。</li><li>**Universal Sentence Encoder (USE)**：一种用于生成句子嵌入的模型，能够生成固定长度的句子向量表示，适用于各种句子级别的任务。</li></ul></li><li><p><strong>Contextual Embeddings（上下文嵌入）</strong>：</p><ul><li><strong>BERT</strong>：通过 Transformer 架构生成上下文相关的嵌入表示，可以为每个单词生成不同的嵌入向量，依赖于单词的上下文。</li><li><strong>GPT</strong>：基于自回归模型生成的嵌入，能够生成连贯的文本和语境感知的嵌入表示。</li></ul></li><li><p><strong>Multimodal Embeddings（多模态嵌入）</strong>：</p><ul><li><strong>CLIP</strong>：结合图像和文本信息的多模态嵌入模型，通过学习图像和文本之间的关联，能够进行跨模态检索和图像-文本匹配。</li></ul></li></ul><p><strong>总而言之，言而总之。Embedding模型可以将用户提供的数据识别制作成库，为Chat模型提供知识基础，安装Embedding模型是构建个人知识库的必要一步。</strong></p><h1 id="基于RAGflow搭建本地知识库"><a href="#基于RAGflow搭建本地知识库" class="headerlink" title="基于RAGflow搭建本地知识库"></a>基于RAGflow搭建本地知识库</h1><p>RAGflow 是一个基于 LLM 的开源知识库构建工具，它提供了一系列的组件，包括数据源、数据处理、模型、评估等，使得用户可以轻松地搭建知识库。开源地址：<a href="https://github.com/infiniflow/ragflow">https://github.com/infiniflow/ragflow</a></p><h2 id="RAGflow搭建步骤"><a href="#RAGflow搭建步骤" class="headerlink" title="RAGflow搭建步骤"></a>RAGflow搭建步骤</h2><p>由于开源仓库中有详细的使用教程，这里简单描述，突出易错关键步骤。</p><h3 id="1-安装Docker"><a href="#1-安装Docker" class="headerlink" title="1.安装Docker"></a>1.安装Docker</h3><p>可以阅读文章<a href="https://blog.csdn.net/Liuj666/article/details/126099982?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522070e248a9f83b077fe95f17e62b30502%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=070e248a9f83b077fe95f17e62b30502&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-126099982-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=Windows%E5%AE%89%E8%A3%85docker&spm=1018.2226.3001.4187">Windows 安装docker（详细图解）</a></p><h3 id="2-git拉取仓库"><a href="#2-git拉取仓库" class="headerlink" title="2.git拉取仓库"></a>2.git拉取仓库</h3><p>通过<code>git clone</code>命令拉取仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/infiniflow/ragflow.git</span><br></pre></td></tr></table></figure><h3 id="3-拉取Docker文件"><a href="#3-拉取Docker文件" class="headerlink" title="3.拉取Docker文件"></a>3.拉取Docker文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ragflow</span><br><span class="line">$ docker compose -f docker/docker-compose.yml up -d</span><br></pre></td></tr></table></figure><p>注意执行该命令时要启动Docker,有条件使用科学上网,最好以管理员权限运行<code>CMD</code>。<br>Docker服务运行成功如图：<br><img src="https://s2.loli.net/2024/12/15/eFGHQdBp7siyRZv.png" width="80%"></p><h3 id="4-添加本地大模型"><a href="#4-添加本地大模型" class="headerlink" title="4.添加本地大模型"></a>4.添加本地大模型</h3><p>我的Ollama和RAGflow都是部署在同一台机器上的，但是RAGflow在Docker中，所以基础URL填写如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://host.docker.internal:11434</span><br></pre></td></tr></table></figure><p>RAGflow中Ollama添加模型如图：<br><img src="https://s2.loli.net/2024/12/15/xnN5JeiCoyhT4Gl.png" width="80%"></p><p>至此搭建工作完成，可以访问<code>http://localhost/knowledge</code>，使用RAGflow提供的服务进行知识库问答。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP32学习笔记</title>
      <link href="/2024/11/24/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/11/24/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="ESP32开发相关链接"><a href="#ESP32开发相关链接" class="headerlink" title="ESP32开发相关链接"></a>ESP32开发相关链接</h1><p>开发ESP32可以采用IDF和Arduino IDE进行开发。为了进一步学习LVGL图形库和FreeRTOS，我选择使用乐鑫IDF进行开发。IDT开发官方文档可见<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.3/esp32/get-started/index.html#id2">快速入门</a></p><h1 id="一些idf常用命令"><a href="#一些idf常用命令" class="headerlink" title="一些idf常用命令"></a>一些idf常用命令</h1><p>idf工具主要调用<code>idf.py</code>这个python脚本，通过传递不同的参数实现不同功能，如交叉编译等。为了终端可以调用该指令需要将其添加路径到系统环境变量中,Linux系统下在目录下运行shell脚本<code>$ ./source export.sh</code>即可自动添加系统环境变量。</p><h2 id="创建一个空工程"><a href="#创建一个空工程" class="headerlink" title="创建一个空工程"></a>创建一个空工程</h2><p>其中my_project为自定义工程名，该命令会创建一个空工程，并生成工程文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py create-project my_project</span><br></pre></td></tr></table></figure><h2 id="设置芯片类型"><a href="#设置芯片类型" class="headerlink" title="设置芯片类型"></a>设置芯片类型</h2><ul><li>ESP32系列模组：idf.py set-target esp32</li><li>ESP32-S2系列模组：idf.py set-target esp32s2</li><li>ESP32-C3系列模组：idf.py set-target esp32c3</li><li>ESP32-S3系列模组：idf.py set-target esp32s3</li></ul><p>这里我们以ESP32-S3系列模组为例，在终端内运行命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py set-target ESP32s3</span><br></pre></td></tr></table></figure><p>idf自动切换为S3型号。</p><h2 id="构建-清除工程"><a href="#构建-清除工程" class="headerlink" title="构建&amp;清除工程"></a>构建&amp;清除工程</h2><p>构建指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py build</span><br></pre></td></tr></table></figure><p>由于芯片具有一定复杂度，编译中产生大量中间文件，编译后工程内存占用高达百兆不利于传递存储。清除编译中间文件指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py clean</span><br></pre></td></tr></table></figure><h2 id="下载-调试工程"><a href="#下载-调试工程" class="headerlink" title="下载&amp;调试工程"></a>下载&amp;调试工程</h2><p>下载指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py flash</span><br></pre></td></tr></table></figure><p>可以使用下面指令监视串口输出，PORT为串口设备，如&#x2F;dev&#x2F;ttyUSB0。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py -p PORT monitor</span><br></pre></td></tr></table></figure><p>也可以直接调试工程，使用下面指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py monitor</span><br></pre></td></tr></table></figure><p><span style="color: red;">特别注意Linux终端退出需要按<kbd>Ctrl</kbd>+<kbd>[</kbd>, 其他什么都不好使。</span></p><h1 id="FreeRTOS基础"><a href="#FreeRTOS基础" class="headerlink" title="FreeRTOS基础"></a>FreeRTOS基础</h1><p>由于ESP32的芯片具有多核特性(如ESP32s3为基于Tensilica Xtensa LX6架构双核芯片)，主核和协处理器分别采用240MHz和160MHz的频率。为了更好的分配任务，所以IDF使用FreeRTOS操作系统进行多线程编程。<br><strong>一个任务可以为以下几种状态</strong>:</p><ul><li><strong>运行(Running)</strong> ：如果处理器为单核，同一时刻只有一个任务被执行。</li><li><strong>准备状态</strong> ：任务处于能够执行但是没有执行的状态，原因为操作系统在执行一些高优先级的任务。</li><li><strong>阻塞(Blocked)</strong> ：任务正在等待时间或者外部事件，如调用<code>vTaskDelay()</code>延时。任务也可以通过阻塞来等待队列、信号量、事件组、通知或信号量事件。处于阻塞状态的任务通常有一个”超时”期， 超时后任务将被超时，并被解除阻塞。</li><li><strong>挂起(Suspended)</strong> ：与“阻塞”状态下的任务一样， “挂起”状态下的任务不能 被选择进入运行状态，但处于挂起状态的任务没有超时。相反，任务只有在分别通过 <code>vTaskSuspend()</code> 和 <code>xTaskResume()</code>API 调用明确命令时 才会进入或退出挂起状态。</li></ul><p><strong>任务优先级</strong>：每个任务均被分配了从 0 到 ( <code>configMAX_PRIORITIES - 1</code> ) 的优先级，其中的<code>configMAX_PRIORITIES</code> 在 <code>FreeRTOSConfig.h</code> 中定义，<span style="color: red;">低优先级数字表示低优先级任务,数字越大任务优先级越高,空闲任务的优先级为零。</span></p><h2 id="FreeRTOS创建任务"><a href="#FreeRTOS创建任务" class="headerlink" title="FreeRTOS创建任务"></a>FreeRTOS创建任务</h2><p>如下是创建一个乐鑫官方移植的任务创建函数<code>xTaskCreatePinnedToCor</code>(<span style="color: red;">推荐使用</span>)它有7个参数，参数为任务函数指针、任务名称、堆栈大小、任务参数、优先级、任务句柄、内核号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreatePinnedToCore</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pvTaskCode, <span class="comment">//任务函数指针，原型是 void fun(void *param)</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *constpcName, <span class="comment">//任务的名称，打印调试可能会有用</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> usStackDepth,<span class="comment">//指定的任务堆栈空间大小（字节）</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> *constpvParameters, <span class="comment">//任务参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority, <span class="comment">// 优先级，数字越大，优先级越大0到(configMAX_PRIORITIES - 1)</span></span></span><br><span class="line"><span class="params">    TaskHandle_t *constpvCreatedTask, <span class="comment">//传回来的任务句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> BaseType_t xCoreID)</span> <span class="comment">//分配在哪个内核上运行</span></span><br></pre></td></tr></table></figure><p>如果任务创建成功则返回pdPASS，否则返回pdFAIL。<br>创建函数还可以是<code>xTaskCreate</code>(内部还是使用了<code>xTaskCreatePinnedToCore</code>但是会自动分配内核)函数及参数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,<span class="comment">//指向任务函数的指针。</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,<span class="comment">//任务的名称（用于调试）。</span></span></span><br><span class="line"><span class="params">    configSTACK_DEPTH_TYPE usStackDepth,<span class="comment">//任务堆栈的深度（以堆栈项为单位）。</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * pvParameters,<span class="comment">//传递给任务函数的参数。</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,<span class="comment">//任务的优先级</span></span></span><br><span class="line"><span class="params">    TaskHandle_t * pxCreatedTask<span class="comment">//用于存储创建的任务句柄的指针（可以为 NULL）。</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h3 id="直接创建任务和静态任务的区别"><a href="#直接创建任务和静态任务的区别" class="headerlink" title="直接创建任务和静态任务的区别"></a>直接创建任务和静态任务的区别</h3><p>在FreeRTOS中，直接创建任务（通常指的是使用<code>xTaskCreate</code>函数动态创建任务）和创建静态任务（使用<code>xTaskCreateStatic</code>函数）之间存在几个关键区别。以下是对这两者的详细比较：<br><strong>1. 内存分配方式</strong></p><ul><li><strong>直接创建任务（动态创建）</strong>：内存是在运行时通过动态内存分配函数（如<code>pvPortMalloc</code>）来分配的。创建任务时，不需要预先定义和初始化额外的变量来存储任务信息。任务的相关信息直接存储在动态分配的内存中。动态创建任务的内存空间可以在任务完成后释放，因此可以在运行时动态地创建和删除任务。</li><li><strong>创建静态任务</strong>：内存是在编译时分配的，需要定义并初始化一个<code>StaticTask_t</code>类型的变量来存储任务的相关信息。静态创建任务的内存空间在任务整个运行期间都被任务所占用，直到任务被删除。静态创建任务通常在应用程序的启动阶段进行，<span style="color: red;">任务的数量是固定的，无法在运行时动态调整。</span><br><strong>2. 内存管理</strong></li><li><strong>直接创建任务</strong>：由于内存是动态分配的，因此需要在任务完成后手动释放内存（尽管FreeRTOS本身可能并不直接提供释放任务内存的API，但可以通过删除任务来间接释放内存）。动态内存分配可能增加内存碎片化的风险。</li><li><strong>创建静态任务</strong>：内存是静态分配的，因此不需要担心内存碎片化和手动释放内存的问题。但由于内存是在编译时分配的，因此需要预先知道任务所需的内存大小。<br><strong>3. 灵活性</strong></li><li><strong>直接创建任务</strong>：提供了更高的灵活性，因为可以在运行时根据需要动态地创建和删除任务。适用于任务数量可能会根据系统状态或用户交互而动态变化的应用场景。</li><li><strong>创建静态任务</strong>：灵活性较低，因为任务的数量和内存大小在编译时就已确定。但由于内存是静态分配的，因此可以提供更稳定的内存使用模式，并减少运行时内存分配的开销。<br><strong>1. 使用场景</strong></li><li><strong>直接创建任务</strong>： 适用于需要动态调整任务数量和类型的系统，如事件驱动系统、多协议通信系统或并行处理系统。</li><li><strong>创建静态任务</strong>：适用于任务数量和类型在编译时就已确定的系统，或对内存使用有严格要求的应用场景。</li></ul><h3 id="创建静态任务的函数"><a href="#创建静态任务的函数" class="headerlink" title="创建静态任务的函数"></a>创建静态任务的函数</h3><p>乐鑫官方移植的FreeRTOS提供了创建静态任务的函数<code>xTaskCreateStaticPinnedToCore</code>，它需要用户提前分配好任务栈和任务控制块的内存，然后调用该函数创建静态任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreateStaticPinnedToCore</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,      <span class="comment">// 指向任务函数的指针，任务函数是任务执行的具体逻辑</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,      <span class="comment">// 任务的名称，用于调试和识别任务</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth,    <span class="comment">// 任务堆栈的大小，以字为单位（通常是4字节）</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * pvParameters,            <span class="comment">// 传递给任务函数的参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,         <span class="comment">// 任务的优先级，优先级较高的任务会优先执行</span></span></span><br><span class="line"><span class="params">    StackType_t * pxStackBuffer,    <span class="comment">// 指向任务堆栈缓冲区的指针，缓冲区必须由调用者分配</span></span></span><br><span class="line"><span class="params">    StaticTask_t * pxStaticTaskBuffer, <span class="comment">// 指向静态任务控制块（TCB）的指针，结构体用于存储任务的相关信息，必须由调用者分配</span></span></span><br><span class="line"><span class="params">    BaseType_t xCoreID              <span class="comment">// 指定任务运行的 CPU 核心 ID，0 或 1</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>FreeRTOS的创建函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreateStatic</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,      <span class="comment">// 指向任务函数的指针，任务函数是任务执行的具体逻辑</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,      <span class="comment">// 任务的名称，用于调试和识别任务</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth,    <span class="comment">// 任务堆栈的大小，以字为单位（通常是4字节）</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * pvParameters,            <span class="comment">// 传递给任务函数的参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,         <span class="comment">// 任务的优先级，优先级较高的任务会优先执行</span></span></span><br><span class="line"><span class="params">    StackType_t * pxStackBuffer,    <span class="comment">// 指向任务堆栈缓冲区的指针，缓冲区必须由调用者分配</span></span></span><br><span class="line"><span class="params">    StaticTask_t * pxStaticTaskBuffer <span class="comment">// 指向静态任务控制块（TCB）的指针，结构体用于存储任务的相关信息，必须由调用者分配</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h3 id="FreeRTOS任务创建案例"><a href="#FreeRTOS任务创建案例" class="headerlink" title="FreeRTOS任务创建案例"></a>FreeRTOS任务创建案例</h3><p>如下创建两个任务并打印相关的数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span><span class="comment">//只要使用FreeRTOS就需要包含该文件，</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span><span class="comment">//创建任务有关的函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span><span class="comment">//用于调试的功能，通过串口打印数据</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*任务A函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskA</span><span class="params">(<span class="type">void</span>* param)</span> <span class="comment">//void*是一种特殊的指针类型，被称为“无类型指针”或“通用指针”。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">100</span>) i++;</span><br><span class="line">        <span class="keyword">else</span> i = <span class="number">0</span>;</span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TaskA&quot;</span>,<span class="string">&quot;Timer_%d&quot;</span>,i);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">500</span>));<span class="comment">//pdMS_TO_TICKS(500)将系统节拍转换成具体时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*任务B函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskB</span><span class="params">(<span class="type">void</span>* param)</span> <span class="comment">//void*是一种特殊的指针类型，被称为“无类型指针”或“通用指针”。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">100</span>) i++;</span><br><span class="line">        <span class="keyword">else</span> i = <span class="number">0</span>;</span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TaskB&quot;</span>,<span class="string">&quot;Timer_%d&quot;</span>,i);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">2000</span>));<span class="comment">//pdMS_TO_TICKS(500)将系统节拍转换成具体时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    xTaskCreatePinnedToCore(TaskA, <span class="string">&quot;TaskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">1</span>);<span class="comment">//栈空间最小2048</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskB, <span class="string">&quot;TaskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">1</span>);<span class="comment">//栈空间最小2048</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FreeRTOS任务阻塞延时"><a href="#FreeRTOS任务阻塞延时" class="headerlink" title="FreeRTOS任务阻塞延时"></a>FreeRTOS任务阻塞延时</h2><p>FreeRTOS提供了两种阻塞延时函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延时 xTicksToDelay 个周期</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">( <span class="type">const</span> TickType_t xTicksToDelay )</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelayUntil</span><span class="params">( <span class="type">const</span> TickType_t *pxPreviousWakeTime, <span class="type">const</span> TickType_t xTimeIncrement )</span>;</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：<code>const TickType_t *pxPreviousWakeTime</code>: 指向上次任务唤醒时间的指针。这个变量应该在第一次调用 vTaskDelayUntil 之前初始化为当前时间。<code>const TickType_t xTimeIncrement</code>: 任务每次执行之间的时间间隔，以滴答数（<code>ticks</code>）为单位。<br><strong>使用步骤</strong>：初始化 <code>pxPreviousWakeTime</code>: 在任务第一次执行时，需要初始化 <code>pxPreviousWakeTime</code> 为当前时间。调用 <code>vTaskDelayUntil</code>: 在每次任务执行结束时，调用<code>vTaskDelayUntil</code>函数，传入<code>pxPreviousWakeTime</code>和<code>xTimeIncrement</code>。<br>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPeriodicTask</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    TickType_t xLastWakeTime;</span><br><span class="line">    <span class="type">const</span> TickType_t xFrequency = <span class="number">1000</span> / portTICK_PERIOD_MS; <span class="comment">// 1000 ms (1 second)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 xLastWakeTime 为当前时间</span></span><br><span class="line">    xLastWakeTime = xTaskGetTickCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 任务执行的逻辑</span></span><br><span class="line">        <span class="comment">// 例如：打印一条消息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Task is running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延迟直到下次唤醒时间</span></span><br><span class="line">        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FreeRTOS任务同步"><a href="#FreeRTOS任务同步" class="headerlink" title="FreeRTOS任务同步"></a>FreeRTOS任务同步</h2><p><strong>RTOS中的同步</strong> ：是指是不同任务之间或者任务与外部事件之间的协同工作方式,确保多个并发执行的任务按照预期的顺序或时机执行。它涉及到线程或任务间的通信和协调机制，目的是为了<span style="color: red;">避免数据竞争、解决竞态条件</span>,并确保系统的正确行为。<br><strong>互斥</strong> ：某一资源同时只允许一个线程或任务访问，其他线程或任务必须等待。<span style="color: red;">具有唯一性和排他性</span>。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是任务间通信的主要形式。 它们可以用于在任务之间以及中断和任务之间发送消息。 在大多数情况下，它们作为线程安全的 FIFO（先进先出）缓冲区使用，新数据被发送到队列的后面， 尽管数据也可以发送到前面。<span style="color: red;">尾部进入，头部读出</span><br><code>QueueHandle_t</code>为队列的句柄类型，本质上是一个指针。常用API函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t <span class="title function_">xQueueCreate</span><span class="params">( <span class="comment">//创建一个队列，成功返回队列句柄</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxQueueLength, <span class="comment">//队列容量</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxItemSize <span class="comment">//每个队列项所占内存的大小（单位是字节）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSend</span><span class="params">( <span class="comment">//向队列头部发送一个消息</span></span></span><br><span class="line"><span class="params">    QueueHandle_t xQueue, <span class="comment">// 队列句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> * pvItemToQueue, <span class="comment">//要发送的消息指针</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSendToBack</span><span class="params">( <span class="comment">//向队列尾部发送一个消息</span></span></span><br><span class="line"><span class="params">    QueueHandle_t xQueue, <span class="comment">// 队列句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> * pvItemToQueue, <span class="comment">//要发送的消息指针</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueReceive</span><span class="params">( <span class="comment">//从队列接收一条消息</span></span></span><br><span class="line"><span class="params">    QueueHandle_t xQueue, <span class="comment">//队列句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * pvBuffer, <span class="comment">//指向接收消息缓冲区的指针。</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSendFromISR</span><span class="params">( <span class="comment">//xQueueSend 的中断版本</span></span></span><br><span class="line"><span class="params">    QueueHandle_t xQueue, <span class="comment">// 队列句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> * pvItemToQueue, <span class="comment">//要发送的消息指针</span></span></span><br><span class="line"><span class="params">    BaseType_t *pxHigherPriorityTaskWoken )</span>; <span class="comment">//指出是否有高优先级的任务被唤醒</span></span><br></pre></td></tr></table></figure><p><strong>队列使用案例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">QueueHandle_t my_queue = <span class="literal">NULL</span>;<span class="comment">//创建队列指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> <span class="comment">//定义一个数据类型</span></span><br><span class="line">    <span class="type">int</span> vslue;</span><br><span class="line">    <span class="type">int</span> Num;</span><br><span class="line">&#125;QueueData;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskA</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//创建任务A，向队列中发送数据</span></span><br><span class="line">&#123;</span><br><span class="line">    QueueData Temp;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;Temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(QueueData));<span class="comment">//初始化结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Temp.Num++;</span><br><span class="line">        Temp.vslue+=<span class="number">2</span>;</span><br><span class="line">        xQueueSend(my_queue, &amp;Temp, <span class="number">100</span>);<span class="comment">//向队列中发送数据</span></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskB</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//创建任务B，从队列中接收数据</span></span><br><span class="line">&#123;</span><br><span class="line">    QueueData Temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pdTRUE == xQueueReceive(my_queue, &amp;Temp, <span class="number">100</span>))<span class="comment">//从队列中接收数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(<span class="string">&quot;TaskB_Receive&quot;</span>, <span class="string">&quot;Value = %d, Num = %d。&quot;</span>,Temp.vslue, Temp.Num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    my_queue = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(QueueData));<span class="comment">//初始化队列</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskA, <span class="string">&quot;TaskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">1</span>);<span class="comment">//创建任务</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskB, <span class="string">&quot;TaskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">3</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是用来保护共享资源不会被多个任务并发使用。信号量使用起来比较简单。因为在 freeRTOS 中它本质上就是队列，只不过<span style="color: red;">信号量只关心队列中的数量而不关心队列中的消息内容</span>，在 freeRTOS 中有两种常用的信号量，一是计数信号量，而是二进制信号量。</p><ul><li>二进制信号量很简单，就是信号量总数只有 1，也就是这个图中总雨伞数量只有 1。</li><li>计数信号量则可以自定义总共的信号量</li></ul><p>信号量的句柄<code>SemaphoreHandle_t</code>,常用API函数如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建二值信号量，成功则返回信号量句柄（二值信号量最大只有 1 个）</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinary</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建计数信号量，成功则返回信号量句柄</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">(</span></span><br><span class="line"><span class="params">    UBaseType_t uxMaxCount, <span class="comment">//最大信号量数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxInitialCount)</span>; <span class="comment">//初始信号量数</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个信号量，如果获得信号量，则返回 pdTRUE</span></span><br><span class="line">xSemaphoreTake( </span><br><span class="line">    SemaphoreHandle_t xSemaphore,<span class="comment">//信号量句柄</span></span><br><span class="line">    TickType_t xTicksToWait ); <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放一个信号量，及放回信号量，成功返回 pdTRUE</span></span><br><span class="line">xSemaphoreGive( SemaphoreHandle_t xSemaphore ); <span class="comment">//信号量句柄</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除信号量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/semphr.h&quot;</span><span class="comment">//信号量有关函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SemaphoreHandle_t My_sem;<span class="comment">//定义信号量的句柄</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskA</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//任务A负责发送信号量</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">        xSemaphoreGive(My_sem); <span class="comment">//信号量句柄</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskB</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//任务B接受到信号量之后打印标记</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pdTRUE == xSemaphoreTake(My_sem, <span class="number">100</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(<span class="string">&quot;TaskB&quot;</span>, <span class="string">&quot;sem is OK&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    My_sem = xSemaphoreCreateBinary();<span class="comment">//初始化句柄</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskA, <span class="string">&quot;TaskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(TaskB, <span class="string">&quot;TaskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁：与二进制信号量类似，但会发生优先级翻转。保证优先级一致性。<br>互斥锁的句柄<code>SemaphoreHandle_t</code>和信号量一样，常用API函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个互斥锁</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutex</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥量获取函数，成功则返回 pdTRUE</span></span><br><span class="line">xSemaphoreTake( </span><br><span class="line">    SemaphoreHandle_t xSemaphore,<span class="comment">//互斥锁句柄</span></span><br><span class="line">    TickType_t xTicksToWait ); <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure><p>获取函数的<code>TickType_t xTicksToWait</code>最好填写<code>portMAX_DELAY</code>无限延时，这样当任务A获取互斥锁后，任务B就无法获取锁了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥量释放函数 </span></span><br><span class="line">xSemaphoreGive( SemaphoreHandle_t xSemaphore ); <span class="comment">//互斥锁句柄</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除互斥锁</span></span><br><span class="line">vSemaphoreDelete( SemaphoreHandle_t xSemaphore );</span><br></pre></td></tr></table></figure><p><strong>示例代码如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/semphr.h&quot;</span><span class="comment">//互斥锁有关函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SemaphoreHandle_t My_Mutex;<span class="comment">//定义互斥锁的句柄</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskA</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//任务A负责发送信号量</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xSemaphoreTake(My_Mutex, portMAX_DELAY);<span class="comment">//获取互斥锁  //</span></span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TaskA&quot;</span>, <span class="string">&quot;Mutex is OK&quot;</span>);                    <span class="comment">//互斥锁保护区域</span></span><br><span class="line">        xSemaphoreGive(My_Mutex); <span class="comment">//释放互斥锁                //</span></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">2000</span>));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskB</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//任务B接受到信号量之后打印标记</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xSemaphoreTake(My_Mutex, portMAX_DELAY);<span class="comment">//获取互斥锁  //</span></span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TaskB&quot;</span>, <span class="string">&quot;Mutex is OK&quot;</span>);                    <span class="comment">//互斥锁保护区域</span></span><br><span class="line">        xSemaphoreGive(My_Mutex); <span class="comment">//释放互斥锁                //</span></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    My_Mutex = xSemaphoreCreateMutex();<span class="comment">//初始化互斥锁句柄</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskA, <span class="string">&quot;TaskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(TaskB, <span class="string">&quot;TaskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FreeRTOS事件组"><a href="#FreeRTOS事件组" class="headerlink" title="FreeRTOS事件组"></a>FreeRTOS事件组</h3><p><strong>事件位</strong>：用于指示事件是否发生，事件位通常称为事件标志。<br><strong>事件组</strong>：就是一组事件位，事件组中的事件位通过位编号来引用。<br>下图表示一个 24 位事件组， 使用 3 个位来保存前面描述的 3 个示例事件<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a5501132ff95ddc8f2d6aef123035ecb.png" alt="EventGroup"><br>接收事件时，可以根据感兴趣的参事件类型接收事件的单个或者多个事件类型。事件接收成功后，必须使用<code>xClearOnExit</code>选项来清除已接收到的事件类型，否则不会清除已接收 到的 事件 ，这样就需要用户显式清除事位。<br>函数句柄<code>EventGroupHandle_t</code>,相关API函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个事件组，返回事件组句柄，失败返回 NULL</span></span><br><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreate</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待事件组中某个标志位,用返回值以确定哪些位已完成设置</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupWaitBits</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">const</span> EventGroupHandle_t xEventGroup, <span class="comment">//事件组句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> EventBits_t uxBitsToWaitFor, <span class="comment">//哪些位需要等待</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> BaseType_t xClearOnExit, <span class="comment">//是否读取完成后自动清除标志位</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> BaseType_t xWaitForAllBits, <span class="comment">//是否等待的标志位都成功了才返回</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//最大阻塞时间</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置标志位</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupSetBits</span><span class="params">(</span></span><br><span class="line"><span class="params">    EventGroupHandle_t xEventGroup,<span class="comment">//事件组句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> EventBits_t uxBitsToSet )</span>; <span class="comment">//设置哪个位</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清除标志位</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupClearBits</span><span class="params">(</span></span><br><span class="line"><span class="params">    EventGroupHandle_t xEventGroup, <span class="comment">//事件组句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> EventBits_t uxBitsToClear )</span>; <span class="comment">//清除的标志位</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// xEventGroup: 事件组句柄，你要删除哪个事件组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vEventGroupDelete</span><span class="params">( EventGroupHandle_t xEventGroup )</span></span><br></pre></td></tr></table></figure><p><strong>示例代码如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/event_groups.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> EventGroupHandle_t s_testEvent;<span class="comment">//事件组句柄</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_taskA</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//事件任务A，用于定时标记事件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xEventGroupSetBits(s_testEvent,BIT0);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">        xEventGroupSetBits(s_testEvent,BIT1);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">event_taskB</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//事件任务B，等待事件组中BIT0和BIT1位</span></span><br><span class="line">&#123;</span><br><span class="line">    EventBits_t ev;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ev = xEventGroupWaitBits(s_testEvent,BIT0|BIT1,pdTRUE,pdFALSE,portMAX_DELAY);</span><br><span class="line">        <span class="keyword">if</span>(ev &amp; BIT0)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG,<span class="string">&quot;Event BIT0 set&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ev&amp; BIT1)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG,<span class="string">&quot;Event BIT1 set&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rtos_event_sample</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//事件例程初始化</span></span><br><span class="line">&#123;</span><br><span class="line">    s_testEvent = xEventGroupCreate();</span><br><span class="line">    xTaskCreatePinnedToCore(event_taskA,<span class="string">&quot;event_taskA&quot;</span>,<span class="number">2048</span>,<span class="literal">NULL</span>,<span class="number">3</span>,<span class="literal">NULL</span>,<span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(event_taskB,<span class="string">&quot;event_taskB&quot;</span>,<span class="number">2048</span>,<span class="literal">NULL</span>,<span class="number">3</span>,<span class="literal">NULL</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="直达任务通知"><a href="#直达任务通知" class="headerlink" title="直达任务通知"></a>直达任务通知</h3><p><strong>定义</strong>：每个 RTOS 任务都有一个任务通知数组。 每条任务通知 都有“挂起”或“非挂起”的通知状态， 以及一个 32 位通知值。直达任务通知是直接发送至任务的事件，而不是通过中间对象 （如队列、事件组或信号量）间接发送至任务的事件。向任务发送“直达任务通知” 会将目标任务通知设为“挂起”状态（此挂起不是挂起任务）。<br><strong>API常用函数如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于将事件直接发送到 RTOS 任务并可能取消该任务的阻塞状态</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotify</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskHandle_t xTaskToNotify, <span class="comment">//要通知的任务句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> ulValue, <span class="comment">//携带的通知值</span></span></span><br><span class="line"><span class="params">    eNotifyAction eAction )</span>; <span class="comment">//执行的操作</span></span><br></pre></td></tr></table></figure><p>需要注意的是参数 eAction 如下表所述:</p><table><thead><tr><th align="center">eAction 设置</th><th align="center">执行的操作</th></tr></thead><tbody><tr><td align="center">eNoAction</td><td align="center">目标任务接收事件，但其 通知值未更新。 在这种情况下，不使用 ulValue。</td></tr><tr><td align="center">eSetBits</td><td align="center">目标任务的通知值 使用 ulValue 按位或运算</td></tr><tr><td align="center">eIncrement</td><td align="center">目标任务的通知值自增 1（类似信号量的 give 操作）</td></tr><tr><td align="center">eSetValueWithOverwrite</td><td align="center">目标任务的通知值 无条件设置为 ulValue。</td></tr><tr><td align="center">eSetValueWithoutOrwrite</td><td align="center">如果目标任务没有 挂起的通知，则其通知值 将设置为 ulValue。如果目标任务已经有 挂起的通知，则不会更新其通知值。</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待接收任务通知</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyWait</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> ulBitsToClearOnEntry, <span class="comment">//进入函数清除的通知值位</span></span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> ulBitsToClearOnExit,<span class="comment">//退出函数清除的通知值位</span></span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> *pulNotificationValue, <span class="comment">//通知值</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//等待时长</span></span><br></pre></td></tr></table></figure><p><strong>示例代码如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/event_groups.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要使用任务通知，需要记录任务句柄</span></span><br><span class="line"><span class="type">static</span> TaskHandle_t s_notifyTaskAHandle;</span><br><span class="line"><span class="type">static</span> TaskHandle_t s_notifyTaskBHandle;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 任务通知A，用于定时向任务通知B直接传输数据</span></span><br><span class="line"><span class="comment"> * @param 无</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">notify_taskA</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> rec_val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (xTaskNotifyWait(<span class="number">0x00</span>, ULONG_MAX, &amp;rec_val, pdMS_TO_TICKS(<span class="number">1000</span>)) == pdTRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG,<span class="string">&quot;receive notify value:%lu&quot;</span>,rec_val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 任务通知B，实时接收任务通知A的数据</span></span><br><span class="line"><span class="comment"> * @param 无</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">notify_taskB</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> notify_val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xTaskNotify(s_notifyTaskAHandle, notify_val, eSetValueWithOverwrite);</span><br><span class="line">        notify_val++;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 任务通知例程初始化</span></span><br><span class="line"><span class="comment"> * @param 无</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtos_notify_sample</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    xTaskCreatePinnedToCore(notify_taskA,<span class="string">&quot;notify_taskA&quot;</span>,<span class="number">2048</span>,<span class="literal">NULL</span>,<span class="number">3</span>,&amp;s_notifyTaskAHandle,<span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(notify_taskB,<span class="string">&quot;notify_taskB&quot;</span>,<span class="number">2048</span>,<span class="literal">NULL</span>,<span class="number">3</span>,&amp;s_notifyTaskBHandle,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LVGL移植"><a href="#LVGL移植" class="headerlink" title="LVGL移植"></a>LVGL移植</h1><h2 id="拉取相关源码"><a href="#拉取相关源码" class="headerlink" title="拉取相关源码"></a>拉取相关源码</h2><p>在github网站上拉取相关的源码，在终端下执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> <span class="built_in">clone</span> --recursive https://github.com/lvgl/lvgl.git</span><br></pre></td></tr></table></figure><p>其中<code>--recursive</code>这是一个可选参数，它告诉Git在克隆主仓库的同时，也递归地克隆所有子模块。如果你的项目使用了Git子模块来引用其他项目，那么你需要使用这个参数来确保所有子模块也都被正确地克隆下来。<br>由于LVGL包含很多的版本，使用指令查看包含的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> tag</span><br></pre></td></tr></table></figure><p>按<code>q</code>退出查看，使用指令切换需要的版本v8.3.10：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> checkout v8.3.10</span><br></pre></td></tr></table></figure><h2 id="添加屏幕驱动"><a href="#添加屏幕驱动" class="headerlink" title="添加屏幕驱动"></a>添加屏幕驱动</h2><p>将驱动文件<code>st7789_driver.c</code>和<code>cst816t_driver.c</code>添加到components文件夹下，并添加<code>CMakeLists.txt</code>。内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">idf_component_register(</span><br><span class="line">    SRCS <span class="string">&quot;st7789_driver.c&quot;</span> <span class="string">&quot;cst816t_driver.c&quot;</span>   //添加相关文件</span><br><span class="line">    INCLUDE_DIRS    <span class="string">&quot;.&quot;</span>                         //添加相关路径为当前路径</span><br><span class="line">    REQUIRES    esp_lcd                         //导入依赖</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="链接lvgl接口"><a href="#链接lvgl接口" class="headerlink" title="链接lvgl接口"></a>链接lvgl接口</h2><p>链接lvgl接口步骤如下：</p><ol><li>初始化和注册LVGL显示驱动</li><li>初始化和注册LVGL触摸驱动</li><li>初始化ST7789硬件接口</li><li>初始化CST816T硬件接口</li><li>提供一个定时器给LVGL使用，作为心跳</li></ol><p>在main目录下添加文件<code>lv_port.c</code>和<code>lv_port.h</code>用于链接lvgl。内容如下：<br><strong>lv_port.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lvgl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;st7789_driver.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cst816t_driver.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driver/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.初始化和注册LVGL显示驱动</span></span><br><span class="line"><span class="comment">2.初始化和注册LVGL触摸驱动</span></span><br><span class="line"><span class="comment">3.初始化ST7789硬件接口</span></span><br><span class="line"><span class="comment">4.初始化CST816T硬件接口</span></span><br><span class="line"><span class="comment">5.提供一个定时器给LVGL使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAG     <span class="string">&quot;lv_port&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_WIDTH       240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_HEIGHT      280</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">lv_disp_drv_t</span>    disp_drv;<span class="comment">//显示驱动变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_flush_done_cb</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">    lv_disp_flush_ready(&amp;disp_drv);<span class="comment">//写入完成通知</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">disp_flush</span><span class="params">(<span class="keyword">struct</span> <span class="type">_lv_disp_drv_t</span> * disp_drv, <span class="type">const</span> <span class="type">lv_area_t</span> * area, <span class="type">lv_color_t</span> * color_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    st7789_flush(area-&gt;x1,area-&gt;x2 + <span class="number">1</span>,area-&gt;y1+<span class="number">20</span>,area-&gt;y2+<span class="number">20</span> + <span class="number">1</span>,color_p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_disp_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">lv_disp_draw_buf_t</span>   disp_buf;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> disp_buf_size = LCD_WIDTH*(LCD_HEIGHT/<span class="number">7</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不能使用C语言的malloc函数</span></span><br><span class="line">    <span class="type">lv_color_t</span> *disp1 = heap_caps_malloc(disp_buf_size*<span class="keyword">sizeof</span>(<span class="type">lv_color_t</span>),MALLOC_CAP_INTERNAL|MALLOC_CAP_DMA);<span class="comment">//MALLOC_CAP_INTERNAL表示从内部ram中申请   MALLOC_CAP_DMA表示需要使用DMA传输</span></span><br><span class="line">    <span class="type">lv_color_t</span> *disp2 = heap_caps_malloc(disp_buf_size*<span class="keyword">sizeof</span>(<span class="type">lv_color_t</span>),MALLOC_CAP_INTERNAL|MALLOC_CAP_DMA);</span><br><span class="line">    <span class="keyword">if</span>(!disp1 || !disp2)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG,<span class="string">&quot;disp buff malloc fail!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lv_disp_draw_buf_init(&amp;disp_buf,disp1,disp2,disp_buf_size);<span class="comment">//双缓存</span></span><br><span class="line"></span><br><span class="line">    lv_disp_drv_init(&amp;disp_drv);<span class="comment">//初始化显示成员</span></span><br><span class="line"></span><br><span class="line">    disp_drv.hor_res = LCD_WIDTH;</span><br><span class="line">    disp_drv.ver_res = LCD_HEIGHT;</span><br><span class="line">    disp_drv.draw_buf = &amp;disp_buf;</span><br><span class="line">    disp_drv.flush_cb = disp_flush;<span class="comment">//显示函数指针</span></span><br><span class="line">    lv_disp_drv_register(&amp;disp_drv);<span class="comment">//将显示驱动注册</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> IRAM_ATTR <span class="title function_">indev_read</span><span class="params">(<span class="keyword">struct</span> <span class="type">_lv_indev_drv_t</span> * indev_drv, <span class="type">lv_indev_data_t</span> * data)</span><span class="comment">//触摸接口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int16_t</span> x,y;</span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line">    cst816t_read(&amp;x,&amp;y,&amp;state);</span><br><span class="line">    data-&gt;point.x = x;</span><br><span class="line">    data-&gt;point.y = y;</span><br><span class="line">    data-&gt;state = state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_indev_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//注册输入驱动</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">lv_indev_drv_t</span> indev_drv;</span><br><span class="line">    lv_indev_drv_init(&amp;indev_drv);</span><br><span class="line">    indev_drv.type = LV_INDEV_TYPE_POINTER;<span class="comment">//输入方式--触摸</span></span><br><span class="line">    indev_drv.read_cb = indev_read;<span class="comment">//触摸函数指针</span></span><br><span class="line">    lv_indev_drv_register(&amp;indev_drv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">st7789_hw_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//初始化LCD硬件接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">st7789_cfg_t</span> st7789_config = &#123;</span><br><span class="line">        .cs = GPIO_NUM_39,</span><br><span class="line">        .bl = GPIO_NUM_45,</span><br><span class="line">        .dc = GPIO_NUM_38,</span><br><span class="line">        .clk = GPIO_NUM_18,</span><br><span class="line">        .mosi = GPIO_NUM_19,</span><br><span class="line">        .rst = GPIO_NUM_47,</span><br><span class="line">        .spi_fre = <span class="number">40</span>*<span class="number">1000</span>*<span class="number">1000</span>,</span><br><span class="line">        .height = LCD_HEIGHT,</span><br><span class="line">        .width = LCD_WIDTH,</span><br><span class="line">        .spin = <span class="number">0</span>,</span><br><span class="line">        .done_cb = lv_flush_done_cb,</span><br><span class="line">        .cb_param = &amp;disp_drv,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    st7789_driver_hw_init(&amp;st7789_config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cst816t_hw_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//初始化触摸硬件接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cst816t_cfg_t</span> cst816t_config = </span><br><span class="line">    &#123;</span><br><span class="line">        .scl = GPIO_NUM_10,</span><br><span class="line">        .sda = GPIO_NUM_11,</span><br><span class="line">        .fre = <span class="number">300</span>*<span class="number">1000</span>,</span><br><span class="line">        .x_limit = LCD_WIDTH,</span><br><span class="line">        .y_limit = LCD_HEIGHT,</span><br><span class="line">    &#125;;</span><br><span class="line">    cst816t_init(&amp;cst816t_config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_timer_cb</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> tick_interval = *((<span class="type">uint32_t</span>*)arg);</span><br><span class="line">    lv_tick_inc(tick_interval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_tick_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//初始化定时器</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> tick_interval = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">esp_timer_create_args_t</span> arg = </span><br><span class="line">    &#123;</span><br><span class="line">        .arg = &amp;tick_interval,</span><br><span class="line">        .callback = lv_timer_cb,<span class="comment">//回调函数</span></span><br><span class="line">        .name = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        .dispatch_method = ESP_TIMER_TASK,</span><br><span class="line">        .skip_unhandled_events = <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">esp_timer_handle_t</span> timer_handle;</span><br><span class="line">    esp_timer_create(&amp;arg,&amp;timer_handle);</span><br><span class="line">    esp_timer_start_periodic(timer_handle,tick_interval*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_port_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lv_init();</span><br><span class="line">    st7789_hw_init();</span><br><span class="line">    cst816t_hw_init();</span><br><span class="line">    lv_disp_init();</span><br><span class="line">    lv_indev_init();</span><br><span class="line">    lv_tick_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lv_port.h</strong></p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LV_PORT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LV_PORT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_port_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="修改ESP32配置文件"><a href="#修改ESP32配置文件" class="headerlink" title="修改ESP32配置文件"></a>修改ESP32配置文件</h2><p>在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py menuconfig</span><br></pre></td></tr></table></figure><ol><li><p>配置flash<br> Serial flasher configuration —&gt; Flash size —&gt; 8MB (32Mb)</p></li><li><p>打开psram<br>Component config —&gt; ESP PSRAM  </p></li><li><p>修改CUP频率<br>Component config —&gt; ESP32 System Settings —&gt; CPU frequency —&gt; 240MHz</p></li><li><p>配置LVGL<br>Component config —&gt; LVGL configuration —&gt; Color setings —&gt; Swap the 2 bytes of RGB565 color.<br>Component config —&gt; LVGL configuration —&gt; Memory settings —&gt; If ture use custom malloc&#x2F;free.&#x2F;&#x2F;将空间放置于psram中</p></li></ol><h1 id="ESP32基础外设"><a href="#ESP32基础外设" class="headerlink" title="ESP32基础外设"></a>ESP32基础外设</h1><h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><h1 id="ESP32开发小坑"><a href="#ESP32开发小坑" class="headerlink" title="ESP32开发小坑"></a>ESP32开发小坑</h1><h2 id="自带rtos延时函数不准问题"><a href="#自带rtos延时函数不准问题" class="headerlink" title="自带rtos延时函数不准问题"></a>自带rtos延时函数不准问题</h2><p> vTaskDelay();函数使用时，要想做到延时确定的时间，需要注意使用portTICK_PERIOD_MS宏进行tick时间转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vTaskDelay(<span class="number">1000</span>/portTICK_PERIOD_MS);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vTaskDelay(pdMS_TO_TICKS(<span class="number">500</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>新文章编写指南</title>
      <link href="/2024/11/18/%E6%96%B0%E6%96%87%E7%AB%A0%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/"/>
      <url>/2024/11/18/%E6%96%B0%E6%96%87%E7%AB%A0%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="兴建Hexo的Markdown博客文章"><a href="#兴建Hexo的Markdown博客文章" class="headerlink" title="兴建Hexo的Markdown博客文章"></a>兴建Hexo的Markdown博客文章</h1><p>在根文件夹打开 git bash 输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;文章名称&quot;</span></span><br></pre></td></tr></table></figure><p>注意必须要输入引号，否则会报错。在<code>\source\_posts</code>目录下会生成一个.md文件,文章可在该文件内编写。</p><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p>具体完整的内容可以查看<a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程</a> 本文章主要记录一些常用的Markdown语法。</p><h2 id="文案标题"><a href="#文案标题" class="headerlink" title="文案标题"></a>文案标题</h2><p>Markdown 标题有两种格式。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">一级标题</span></span><br><span class="line"><span class="section">=================</span></span><br><span class="line"></span><br><span class="line"><span class="section">二级标题</span></span><br><span class="line"><span class="section">-----------------</span></span><br></pre></td></tr></table></figure><p>该方法 <code>=</code> 和 <code>-</code> 的个数可以随意，但是不常用。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><p>该方法较为常用，但是要注意<code>#</code>的后面一定要加上空格<code> </code>否则语法不起作用。</p><h2 id="嵌入代码"><a href="#嵌入代码" class="headerlink" title="嵌入代码"></a>嵌入代码</h2><p>在文字段中加入编码可以使用两个符号“ &#96; ”来包裹，该符号位于键盘的 <kbd>esc</kbd> 键下面。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`printf(&quot;Hello World!&quot;)`</span></span><br></pre></td></tr></table></figure><p>Markdown效果：<code>printf(&quot;Hello World!&quot;)</code><br>当代码量相对较大时，可以使用两个<code>```</code>来包裹。第一个<code>```</code>后面可以加入语言名，如<code>C</code>，这样Markdown就会根据语言名高亮显示。编码如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\ <span class="code">```C</span></span><br><span class="line"><span class="code"> #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"> int main(int argc, char *argv[], char *envp[])</span></span><br><span class="line"><span class="code"> &#123;</span></span><br><span class="line"><span class="code">     printf(&quot;Hello World!\n&quot;);</span></span><br><span class="line"><span class="code">     return 0;</span></span><br><span class="line"><span class="code"> &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"> \```</span></span><br></pre></td></tr></table></figure><p>Markdown效果,可见语法已经被高亮显示了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h2><p>Markdown可以将链接嵌入文字中<code>[链接名称](链接地址)</code>，此时只显示链接中的链接名称，点击链接可以跳转到链接地址，举例如下。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">Fred&#x27;s Blog</span>](<span class="link">https://jasting10.github.io/</span>)</span><br></pre></td></tr></table></figure><p>效果如下:<a href="https://jasting10.github.io/">Fred’s Blog</a></p><p>当然也可以直接显示出需要跳转的链接，可以使用 <code>&lt;链接地址&gt;</code> 举例如下。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">&lt;https://jasting10.github.io/&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下:<a href="https://jasting10.github.io/">https://jasting10.github.io/</a></p><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>图片语法格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">alt 属性文本</span>](<span class="link">图片地址</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">alt 属性文本</span>](<span class="link">图片地址 &quot;可选标题&quot;</span>)</span><br></pre></td></tr></table></figure><p>可见该语法和嵌入链接的语法相似，举例如下。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">hummingbird.jpeg</span>](<span class="link">https://s2.loli.net/2024/11/14/s6jWuxrelG8Y52Z.jpg</span>)</span><br></pre></td></tr></table></figure><p>效果如下:<br><img src="https://s2.loli.net/2024/11/14/s6jWuxrelG8Y52Z.jpg" width="50%"><br>Markdown还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code>标签。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s2.loli.net/2024/11/14/s6jWuxrelG8Y52Z.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果如下,图像缩小长宽均50%:<br><img src="https://s2.loli.net/2024/11/14/s6jWuxrelG8Y52Z.jpg" width="25%"></p><h2 id="文字编辑"><a href="#文字编辑" class="headerlink" title="文字编辑"></a>文字编辑</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>Markdown 可以使用以下几种字体：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本*</span>**</span></span><br><span class="line"><span class="strong">__<span class="emphasis">_粗斜体文本_</span>__</span></span><br></pre></td></tr></table></figure><p>效果如下：<br><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线可以通过 HTML 的 <code>&lt;u&gt;</code> 标签来实现：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>带下划线文本<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果如下：<u>带下划线文本</u></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~BAIDU.COM~~</span><br></pre></td></tr></table></figure><p>效果如下：<del>BAIDU.COM</del></p><p><strong><strong>后续如用到新语法会继续更新文章</strong></strong></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
