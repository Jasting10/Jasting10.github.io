<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ESP32学习笔记</title>
      <link href="/2024/11/24/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/11/24/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="ESP32开发相关链接"><a href="#ESP32开发相关链接" class="headerlink" title="ESP32开发相关链接"></a>ESP32开发相关链接</h1><p>开发ESP32可以采用IDF和Arduino IDE进行开发。为了进一步学习LVGL图形库和FreeRTOS，我选择使用乐鑫IDF进行开发。IDT开发官方文档可见<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.3/esp32/get-started/index.html#id2">快速入门</a></p><h1 id="一些idf常用命令"><a href="#一些idf常用命令" class="headerlink" title="一些idf常用命令"></a>一些idf常用命令</h1><p>idf工具主要调用<code>idf.py</code>这个python脚本，通过传递不同的参数实现不同功能，如交叉编译等。为了终端可以调用该指令需要将其添加路径到系统环境变量中,Linux系统下在目录下运行shell脚本<code>$ ./source export.sh</code>即可自动添加系统环境变量。</p><h2 id="创建一个空工程"><a href="#创建一个空工程" class="headerlink" title="创建一个空工程"></a>创建一个空工程</h2><p>其中my_project为自定义工程名，该命令会创建一个空工程，并生成工程文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py create-project my_project</span><br></pre></td></tr></table></figure><h2 id="设置芯片类型"><a href="#设置芯片类型" class="headerlink" title="设置芯片类型"></a>设置芯片类型</h2><ul><li>ESP32系列模组：idf.py set-target esp32</li><li>ESP32-S2系列模组：idf.py set-target esp32s2</li><li>ESP32-C3系列模组：idf.py set-target esp32c3</li><li>ESP32-S3系列模组：idf.py set-target esp32s3</li></ul><p>这里我们以ESP32-S3系列模组为例，在终端内运行命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py set-target ESP32s3</span><br></pre></td></tr></table></figure><p>idf自动切换为S3型号。</p><h2 id="构建-清除工程"><a href="#构建-清除工程" class="headerlink" title="构建&amp;清除工程"></a>构建&amp;清除工程</h2><p>构建指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py build</span><br></pre></td></tr></table></figure><p>由于芯片具有一定复杂度，编译中产生大量中间文件，编译后工程内存占用高达百兆不利于传递存储。清除编译中间文件指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py clean</span><br></pre></td></tr></table></figure><h2 id="下载-调试工程"><a href="#下载-调试工程" class="headerlink" title="下载&amp;调试工程"></a>下载&amp;调试工程</h2><p>下载指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py flash</span><br></pre></td></tr></table></figure><p>可以使用下面指令监视串口输出，PORT为串口设备，如&#x2F;dev&#x2F;ttyUSB0。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py -p PORT monitor</span><br></pre></td></tr></table></figure><p>也可以直接调试工程，使用下面指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py monitor</span><br></pre></td></tr></table></figure><p><span style="color: red;">特别注意Linux终端退出需要按<kbd>Ctrl</kbd>+<kbd>[</kbd>, 其他什么都不好使。</span></p><h1 id="FreeRTOS基础"><a href="#FreeRTOS基础" class="headerlink" title="FreeRTOS基础"></a>FreeRTOS基础</h1><p>由于ESP32的芯片具有多核特性(如ESP32s3为基于Tensilica Xtensa LX6架构双核芯片)，主核和协处理器分别采用240MHz和160MHz的频率。为了更好的分配任务，所以IDF使用FreeRTOS操作系统进行多线程编程。<br><strong>一个任务可以为以下几种状态</strong>:</p><ul><li><strong>运行(Running)</strong> ：如果处理器为单核，同一时刻只有一个任务被执行。</li><li><strong>准备状态</strong> ：任务处于能够执行但是没有执行的状态，原因为操作系统在执行一些高优先级的任务。</li><li><strong>阻塞(Blocked)</strong> ：任务正在等待时间或者外部事件，如调用<code>vTaskDelay()</code>延时。任务也可以通过阻塞来等待队列、信号量、事件组、通知或信号量事件。处于阻塞状态的任务通常有一个”超时”期， 超时后任务将被超时，并被解除阻塞。</li><li><strong>挂起(Suspended)</strong> ：与“阻塞”状态下的任务一样， “挂起”状态下的任务不能 被选择进入运行状态，但处于挂起状态的任务没有超时。相反，任务只有在分别通过 <code>vTaskSuspend()</code> 和 <code>xTaskResume()</code>API 调用明确命令时 才会进入或退出挂起状态。</li></ul><p><strong>任务优先级</strong>：每个任务均被分配了从 0 到 ( <code>configMAX_PRIORITIES - 1</code> ) 的优先级，其中的<code>configMAX_PRIORITIES</code> 在 <code>FreeRTOSConfig.h</code> 中定义，<span style="color: red;">低优先级数字表示低优先级任务,数字越大任务优先级越高,空闲任务的优先级为零。</span></p><h2 id="FreeRTOS创建任务"><a href="#FreeRTOS创建任务" class="headerlink" title="FreeRTOS创建任务"></a>FreeRTOS创建任务</h2><p>如下是创建一个乐鑫官方移植的任务创建函数<code>xTaskCreatePinnedToCor</code>(<span style="color: red;">推荐使用</span>)它有7个参数，参数为任务函数指针、任务名称、堆栈大小、任务参数、优先级、任务句柄、内核号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreatePinnedToCore</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pvTaskCode, <span class="comment">//任务函数指针，原型是 void fun(void *param)</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *constpcName, <span class="comment">//任务的名称，打印调试可能会有用</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> usStackDepth,<span class="comment">//指定的任务堆栈空间大小（字节）</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> *constpvParameters, <span class="comment">//任务参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority, <span class="comment">// 优先级，数字越大，优先级越大0到(configMAX_PRIORITIES - 1)</span></span></span><br><span class="line"><span class="params">    TaskHandle_t *constpvCreatedTask, <span class="comment">//传回来的任务句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> BaseType_t xCoreID)</span> <span class="comment">//分配在哪个内核上运行</span></span><br></pre></td></tr></table></figure><p>如果任务创建成功则返回pdPASS，否则返回pdFAIL。<br>创建函数还可以是<code>xTaskCreate</code>(内部还是使用了<code>xTaskCreatePinnedToCore</code>但是会自动分配内核)函数及参数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,<span class="comment">//指向任务函数的指针。</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,<span class="comment">//任务的名称（用于调试）。</span></span></span><br><span class="line"><span class="params">    configSTACK_DEPTH_TYPE usStackDepth,<span class="comment">//任务堆栈的深度（以堆栈项为单位）。</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * pvParameters,<span class="comment">//传递给任务函数的参数。</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,<span class="comment">//任务的优先级</span></span></span><br><span class="line"><span class="params">    TaskHandle_t * pxCreatedTask<span class="comment">//用于存储创建的任务句柄的指针（可以为 NULL）。</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h3 id="直接创建任务和静态任务的区别"><a href="#直接创建任务和静态任务的区别" class="headerlink" title="直接创建任务和静态任务的区别"></a>直接创建任务和静态任务的区别</h3><p>在FreeRTOS中，直接创建任务（通常指的是使用<code>xTaskCreate</code>函数动态创建任务）和创建静态任务（使用<code>xTaskCreateStatic</code>函数）之间存在几个关键区别。以下是对这两者的详细比较：<br><strong>1. 内存分配方式</strong></p><ul><li><strong>直接创建任务（动态创建）</strong>：内存是在运行时通过动态内存分配函数（如<code>pvPortMalloc</code>）来分配的。创建任务时，不需要预先定义和初始化额外的变量来存储任务信息。任务的相关信息直接存储在动态分配的内存中。动态创建任务的内存空间可以在任务完成后释放，因此可以在运行时动态地创建和删除任务。</li><li><strong>创建静态任务</strong>：内存是在编译时分配的，需要定义并初始化一个<code>StaticTask_t</code>类型的变量来存储任务的相关信息。静态创建任务的内存空间在任务整个运行期间都被任务所占用，直到任务被删除。静态创建任务通常在应用程序的启动阶段进行，<span style="color: red;">任务的数量是固定的，无法在运行时动态调整。</span><br><strong>2. 内存管理</strong></li><li><strong>直接创建任务</strong>：由于内存是动态分配的，因此需要在任务完成后手动释放内存（尽管FreeRTOS本身可能并不直接提供释放任务内存的API，但可以通过删除任务来间接释放内存）。动态内存分配可能增加内存碎片化的风险。</li><li><strong>创建静态任务</strong>：内存是静态分配的，因此不需要担心内存碎片化和手动释放内存的问题。但由于内存是在编译时分配的，因此需要预先知道任务所需的内存大小。<br><strong>3. 灵活性</strong></li><li><strong>直接创建任务</strong>：提供了更高的灵活性，因为可以在运行时根据需要动态地创建和删除任务。适用于任务数量可能会根据系统状态或用户交互而动态变化的应用场景。</li><li><strong>创建静态任务</strong>：灵活性较低，因为任务的数量和内存大小在编译时就已确定。但由于内存是静态分配的，因此可以提供更稳定的内存使用模式，并减少运行时内存分配的开销。<br><strong>1. 使用场景</strong></li><li><strong>直接创建任务</strong>： 适用于需要动态调整任务数量和类型的系统，如事件驱动系统、多协议通信系统或并行处理系统。</li><li><strong>创建静态任务</strong>：适用于任务数量和类型在编译时就已确定的系统，或对内存使用有严格要求的应用场景。</li></ul><h3 id="创建静态任务的函数"><a href="#创建静态任务的函数" class="headerlink" title="创建静态任务的函数"></a>创建静态任务的函数</h3><p>乐鑫官方移植的FreeRTOS提供了创建静态任务的函数<code>xTaskCreateStaticPinnedToCore</code>，它需要用户提前分配好任务栈和任务控制块的内存，然后调用该函数创建静态任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreateStaticPinnedToCore</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,      <span class="comment">// 指向任务函数的指针，任务函数是任务执行的具体逻辑</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,      <span class="comment">// 任务的名称，用于调试和识别任务</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth,    <span class="comment">// 任务堆栈的大小，以字为单位（通常是4字节）</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * pvParameters,            <span class="comment">// 传递给任务函数的参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,         <span class="comment">// 任务的优先级，优先级较高的任务会优先执行</span></span></span><br><span class="line"><span class="params">    StackType_t * pxStackBuffer,    <span class="comment">// 指向任务堆栈缓冲区的指针，缓冲区必须由调用者分配</span></span></span><br><span class="line"><span class="params">    StaticTask_t * pxStaticTaskBuffer, <span class="comment">// 指向静态任务控制块（TCB）的指针，结构体用于存储任务的相关信息，必须由调用者分配</span></span></span><br><span class="line"><span class="params">    BaseType_t xCoreID              <span class="comment">// 指定任务运行的 CPU 核心 ID，0 或 1</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>FreeRTOS的创建函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreateStatic</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,      <span class="comment">// 指向任务函数的指针，任务函数是任务执行的具体逻辑</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,      <span class="comment">// 任务的名称，用于调试和识别任务</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth,    <span class="comment">// 任务堆栈的大小，以字为单位（通常是4字节）</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * pvParameters,            <span class="comment">// 传递给任务函数的参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,         <span class="comment">// 任务的优先级，优先级较高的任务会优先执行</span></span></span><br><span class="line"><span class="params">    StackType_t * pxStackBuffer,    <span class="comment">// 指向任务堆栈缓冲区的指针，缓冲区必须由调用者分配</span></span></span><br><span class="line"><span class="params">    StaticTask_t * pxStaticTaskBuffer <span class="comment">// 指向静态任务控制块（TCB）的指针，结构体用于存储任务的相关信息，必须由调用者分配</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h3 id="FreeRTOS任务创建案例"><a href="#FreeRTOS任务创建案例" class="headerlink" title="FreeRTOS任务创建案例"></a>FreeRTOS任务创建案例</h3><p>如下创建两个任务并打印相关的数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span><span class="comment">//只要使用FreeRTOS就需要包含该文件，</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span><span class="comment">//创建任务有关的函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span><span class="comment">//用于调试的功能，通过串口打印数据</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*任务A函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskA</span><span class="params">(<span class="type">void</span>* param)</span> <span class="comment">//void*是一种特殊的指针类型，被称为“无类型指针”或“通用指针”。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">100</span>) i++;</span><br><span class="line">        <span class="keyword">else</span> i = <span class="number">0</span>;</span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TaskA&quot;</span>,<span class="string">&quot;Timer_%d&quot;</span>,i);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">500</span>));<span class="comment">//pdMS_TO_TICKS(500)将系统节拍转换成具体时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*任务B函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskB</span><span class="params">(<span class="type">void</span>* param)</span> <span class="comment">//void*是一种特殊的指针类型，被称为“无类型指针”或“通用指针”。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">100</span>) i++;</span><br><span class="line">        <span class="keyword">else</span> i = <span class="number">0</span>;</span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TaskB&quot;</span>,<span class="string">&quot;Timer_%d&quot;</span>,i);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">2000</span>));<span class="comment">//pdMS_TO_TICKS(500)将系统节拍转换成具体时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    xTaskCreatePinnedToCore(TaskA, <span class="string">&quot;TaskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">1</span>);<span class="comment">//栈空间最小2048</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskB, <span class="string">&quot;TaskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">1</span>);<span class="comment">//栈空间最小2048</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FreeRTOS任务阻塞延时"><a href="#FreeRTOS任务阻塞延时" class="headerlink" title="FreeRTOS任务阻塞延时"></a>FreeRTOS任务阻塞延时</h2><p>FreeRTOS提供了两种阻塞延时函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延时 xTicksToDelay 个周期</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">( <span class="type">const</span> TickType_t xTicksToDelay )</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelayUntil</span><span class="params">( <span class="type">const</span> TickType_t *pxPreviousWakeTime, <span class="type">const</span> TickType_t xTimeIncrement )</span>;</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：<code>const TickType_t *pxPreviousWakeTime</code>: 指向上次任务唤醒时间的指针。这个变量应该在第一次调用 vTaskDelayUntil 之前初始化为当前时间。<code>const TickType_t xTimeIncrement</code>: 任务每次执行之间的时间间隔，以滴答数（<code>ticks</code>）为单位。<br><strong>使用步骤</strong>：初始化 <code>pxPreviousWakeTime</code>: 在任务第一次执行时，需要初始化 <code>pxPreviousWakeTime</code> 为当前时间。调用 <code>vTaskDelayUntil</code>: 在每次任务执行结束时，调用<code>vTaskDelayUntil</code>函数，传入<code>pxPreviousWakeTime</code>和<code>xTimeIncrement</code>。<br>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPeriodicTask</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    TickType_t xLastWakeTime;</span><br><span class="line">    <span class="type">const</span> TickType_t xFrequency = <span class="number">1000</span> / portTICK_PERIOD_MS; <span class="comment">// 1000 ms (1 second)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 xLastWakeTime 为当前时间</span></span><br><span class="line">    xLastWakeTime = xTaskGetTickCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 任务执行的逻辑</span></span><br><span class="line">        <span class="comment">// 例如：打印一条消息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Task is running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延迟直到下次唤醒时间</span></span><br><span class="line">        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FreeRTOS任务同步"><a href="#FreeRTOS任务同步" class="headerlink" title="FreeRTOS任务同步"></a>FreeRTOS任务同步</h2><p><strong>RTOS中的同步</strong> ：是指是不同任务之间或者任务与外部事件之间的协同工作方式,确保多个并发执行的任务按照预期的顺序或时机执行。它涉及到线程或任务间的通信和协调机制，目的是为了<span style="color: red;">避免数据竞争、解决竞态条件</span>,并确保系统的正确行为。<br><strong>互斥</strong> ：某一资源同时只允许一个线程或任务访问，其他线程或任务必须等待。<span style="color: red;">具有唯一性和排他性</span>。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是任务间通信的主要形式。 它们可以用于在任务之间以及中断和任务之间发送消息。 在大多数情况下，它们作为线程安全的 FIFO（先进先出）缓冲区使用，新数据被发送到队列的后面， 尽管数据也可以发送到前面。<span style="color: red;">尾部进入，头部读出</span><br><code>QueueHandle_t</code>为队列的句柄类型，本质上是一个指针。常用API函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t <span class="title function_">xQueueCreate</span><span class="params">( <span class="comment">//创建一个队列，成功返回队列句柄</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxQueueLength, <span class="comment">//队列容量</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxItemSize <span class="comment">//每个队列项所占内存的大小（单位是字节）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSend</span><span class="params">( <span class="comment">//向队列头部发送一个消息</span></span></span><br><span class="line"><span class="params">    QueueHandle_t xQueue, <span class="comment">// 队列句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> * pvItemToQueue, <span class="comment">//要发送的消息指针</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSendToBack</span><span class="params">( <span class="comment">//向队列尾部发送一个消息</span></span></span><br><span class="line"><span class="params">    QueueHandle_t xQueue, <span class="comment">// 队列句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> * pvItemToQueue, <span class="comment">//要发送的消息指针</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueReceive</span><span class="params">( <span class="comment">//从队列接收一条消息</span></span></span><br><span class="line"><span class="params">    QueueHandle_t xQueue, <span class="comment">//队列句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * pvBuffer, <span class="comment">//指向接收消息缓冲区的指针。</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSendFromISR</span><span class="params">( <span class="comment">//xQueueSend 的中断版本</span></span></span><br><span class="line"><span class="params">    QueueHandle_t xQueue, <span class="comment">// 队列句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> * pvItemToQueue, <span class="comment">//要发送的消息指针</span></span></span><br><span class="line"><span class="params">    BaseType_t *pxHigherPriorityTaskWoken )</span>; <span class="comment">//指出是否有高优先级的任务被唤醒</span></span><br></pre></td></tr></table></figure><p><strong>队列使用案例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">QueueHandle_t my_queue = <span class="literal">NULL</span>;<span class="comment">//创建队列指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> <span class="comment">//定义一个数据类型</span></span><br><span class="line">    <span class="type">int</span> vslue;</span><br><span class="line">    <span class="type">int</span> Num;</span><br><span class="line">&#125;QueueData;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskA</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//创建任务A，向队列中发送数据</span></span><br><span class="line">&#123;</span><br><span class="line">    QueueData Temp;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;Temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(QueueData));<span class="comment">//初始化结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Temp.Num++;</span><br><span class="line">        Temp.vslue+=<span class="number">2</span>;</span><br><span class="line">        xQueueSend(my_queue, &amp;Temp, <span class="number">100</span>);<span class="comment">//向队列中发送数据</span></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskB</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//创建任务B，从队列中接收数据</span></span><br><span class="line">&#123;</span><br><span class="line">    QueueData Temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pdTRUE == xQueueReceive(my_queue, &amp;Temp, <span class="number">100</span>))<span class="comment">//从队列中接收数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(<span class="string">&quot;TaskB_Receive&quot;</span>, <span class="string">&quot;Value = %d, Num = %d。&quot;</span>,Temp.vslue, Temp.Num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    my_queue = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(QueueData));<span class="comment">//初始化队列</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskA, <span class="string">&quot;TaskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">1</span>);<span class="comment">//创建任务</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskB, <span class="string">&quot;TaskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">3</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是用来保护共享资源不会被多个任务并发使用。信号量使用起来比较简单。因为在 freeRTOS 中它本质上就是队列，只不过<span style="color: red;">信号量只关心队列中的数量而不关心队列中的消息内容</span>，在 freeRTOS 中有两种常用的信号量，一是计数信号量，而是二进制信号量。</p><ul><li>二进制信号量很简单，就是信号量总数只有 1，也就是这个图中总雨伞数量只有 1。</li><li>计数信号量则可以自定义总共的信号量</li></ul><p>信号量的句柄<code>SemaphoreHandle_t</code>,常用API函数如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建二值信号量，成功则返回信号量句柄（二值信号量最大只有 1 个）</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinary</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建计数信号量，成功则返回信号量句柄</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">(</span></span><br><span class="line"><span class="params">    UBaseType_t uxMaxCount, <span class="comment">//最大信号量数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxInitialCount)</span>; <span class="comment">//初始信号量数</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个信号量，如果获得信号量，则返回 pdTRUE</span></span><br><span class="line">xSemaphoreTake( </span><br><span class="line">    SemaphoreHandle_t xSemaphore,<span class="comment">//信号量句柄</span></span><br><span class="line">    TickType_t xTicksToWait ); <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放一个信号量，及放回信号量，成功返回 pdTRUE</span></span><br><span class="line">xSemaphoreGive( SemaphoreHandle_t xSemaphore ); <span class="comment">//信号量句柄</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除信号量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/semphr.h&quot;</span><span class="comment">//信号量有关函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SemaphoreHandle_t My_sem;<span class="comment">//定义信号量的句柄</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskA</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//任务A负责发送信号量</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">        xSemaphoreGive(My_sem); <span class="comment">//信号量句柄</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskB</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//任务B接受到信号量之后打印标记</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pdTRUE == xSemaphoreTake(My_sem, <span class="number">100</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(<span class="string">&quot;TaskB&quot;</span>, <span class="string">&quot;sem is OK&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    My_sem = xSemaphoreCreateBinary();<span class="comment">//初始化句柄</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskA, <span class="string">&quot;TaskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(TaskB, <span class="string">&quot;TaskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁：与二进制信号量类似，但会发生优先级翻转。保证优先级一致性。<br>互斥锁的句柄<code>SemaphoreHandle_t</code>和信号量一样，常用API函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个互斥锁</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutex</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥量获取函数，成功则返回 pdTRUE</span></span><br><span class="line">xSemaphoreTake( </span><br><span class="line">    SemaphoreHandle_t xSemaphore,<span class="comment">//互斥锁句柄</span></span><br><span class="line">    TickType_t xTicksToWait ); <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure><p>获取函数的<code>TickType_t xTicksToWait</code>最好填写<code>portMAX_DELAY</code>无限延时，这样当任务A获取互斥锁后，任务B就无法获取锁了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥量释放函数 </span></span><br><span class="line">xSemaphoreGive( SemaphoreHandle_t xSemaphore ); <span class="comment">//互斥锁句柄</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除互斥锁</span></span><br><span class="line">vSemaphoreDelete( SemaphoreHandle_t xSemaphore );</span><br></pre></td></tr></table></figure><p><strong>示例代码如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/semphr.h&quot;</span><span class="comment">//互斥锁有关函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SemaphoreHandle_t My_Mutex;<span class="comment">//定义互斥锁的句柄</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskA</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//任务A负责发送信号量</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xSemaphoreTake(My_Mutex, portMAX_DELAY);<span class="comment">//获取互斥锁  //</span></span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TaskA&quot;</span>, <span class="string">&quot;Mutex is OK&quot;</span>);                    <span class="comment">//互斥锁保护区域</span></span><br><span class="line">        xSemaphoreGive(My_Mutex); <span class="comment">//释放互斥锁                //</span></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">2000</span>));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskB</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//任务B接受到信号量之后打印标记</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xSemaphoreTake(My_Mutex, portMAX_DELAY);<span class="comment">//获取互斥锁  //</span></span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TaskB&quot;</span>, <span class="string">&quot;Mutex is OK&quot;</span>);                    <span class="comment">//互斥锁保护区域</span></span><br><span class="line">        xSemaphoreGive(My_Mutex); <span class="comment">//释放互斥锁                //</span></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    My_Mutex = xSemaphoreCreateMutex();<span class="comment">//初始化互斥锁句柄</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskA, <span class="string">&quot;TaskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(TaskB, <span class="string">&quot;TaskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FreeRTOS事件组"><a href="#FreeRTOS事件组" class="headerlink" title="FreeRTOS事件组"></a>FreeRTOS事件组</h3><p><strong>事件位</strong>：用于指示事件是否发生，事件位通常称为事件标志。<br><strong>事件组</strong>：就是一组事件位，事件组中的事件位通过位编号来引用。<br>下图表示一个 24 位事件组， 使用 3 个位来保存前面描述的 3 个示例事件<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a5501132ff95ddc8f2d6aef123035ecb.png" alt="EventGroup"><br>接收事件时，可以根据感兴趣的参事件类型接收事件的单个或者多个事件类型。事件接收成功后，必须使用<code>xClearOnExit</code>选项来清除已接收到的事件类型，否则不会清除已接收 到的 事件 ，这样就需要用户显式清除事位。<br>函数句柄<code>EventGroupHandle_t</code>,相关API函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个事件组，返回事件组句柄，失败返回 NULL</span></span><br><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreate</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待事件组中某个标志位,用返回值以确定哪些位已完成设置</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupWaitBits</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">const</span> EventGroupHandle_t xEventGroup, <span class="comment">//事件组句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> EventBits_t uxBitsToWaitFor, <span class="comment">//哪些位需要等待</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> BaseType_t xClearOnExit, <span class="comment">//是否读取完成后自动清除标志位</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> BaseType_t xWaitForAllBits, <span class="comment">//是否等待的标志位都成功了才返回</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//最大阻塞时间</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置标志位</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupSetBits</span><span class="params">(</span></span><br><span class="line"><span class="params">    EventGroupHandle_t xEventGroup,<span class="comment">//事件组句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> EventBits_t uxBitsToSet )</span>; <span class="comment">//设置哪个位</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清除标志位</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupClearBits</span><span class="params">(</span></span><br><span class="line"><span class="params">    EventGroupHandle_t xEventGroup, <span class="comment">//事件组句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> EventBits_t uxBitsToClear )</span>; <span class="comment">//清除的标志位</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// xEventGroup: 事件组句柄，你要删除哪个事件组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vEventGroupDelete</span><span class="params">( EventGroupHandle_t xEventGroup )</span></span><br></pre></td></tr></table></figure><p><strong>示例代码如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/event_groups.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> EventGroupHandle_t s_testEvent;<span class="comment">//事件组句柄</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_taskA</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//事件任务A，用于定时标记事件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xEventGroupSetBits(s_testEvent,BIT0);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">        xEventGroupSetBits(s_testEvent,BIT1);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">event_taskB</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//事件任务B，等待事件组中BIT0和BIT1位</span></span><br><span class="line">&#123;</span><br><span class="line">    EventBits_t ev;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ev = xEventGroupWaitBits(s_testEvent,BIT0|BIT1,pdTRUE,pdFALSE,portMAX_DELAY);</span><br><span class="line">        <span class="keyword">if</span>(ev &amp; BIT0)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG,<span class="string">&quot;Event BIT0 set&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ev&amp; BIT1)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG,<span class="string">&quot;Event BIT1 set&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rtos_event_sample</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//事件例程初始化</span></span><br><span class="line">&#123;</span><br><span class="line">    s_testEvent = xEventGroupCreate();</span><br><span class="line">    xTaskCreatePinnedToCore(event_taskA,<span class="string">&quot;event_taskA&quot;</span>,<span class="number">2048</span>,<span class="literal">NULL</span>,<span class="number">3</span>,<span class="literal">NULL</span>,<span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(event_taskB,<span class="string">&quot;event_taskB&quot;</span>,<span class="number">2048</span>,<span class="literal">NULL</span>,<span class="number">3</span>,<span class="literal">NULL</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="直达任务通知"><a href="#直达任务通知" class="headerlink" title="直达任务通知"></a>直达任务通知</h3><p><strong>定义</strong>：每个 RTOS 任务都有一个任务通知数组。 每条任务通知 都有“挂起”或“非挂起”的通知状态， 以及一个 32 位通知值。直达任务通知是直接发送至任务的事件，而不是通过中间对象 （如队列、事件组或信号量）间接发送至任务的事件。向任务发送“直达任务通知” 会将目标任务通知设为“挂起”状态（此挂起不是挂起任务）。<br><strong>API常用函数如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于将事件直接发送到 RTOS 任务并可能取消该任务的阻塞状态</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotify</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskHandle_t xTaskToNotify, <span class="comment">//要通知的任务句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> ulValue, <span class="comment">//携带的通知值</span></span></span><br><span class="line"><span class="params">    eNotifyAction eAction )</span>; <span class="comment">//执行的操作</span></span><br></pre></td></tr></table></figure><p>需要注意的是参数 eAction 如下表所述:</p><table><thead><tr><th align="center">eAction 设置</th><th align="center">执行的操作</th></tr></thead><tbody><tr><td align="center">eNoAction</td><td align="center">目标任务接收事件，但其 通知值未更新。 在这种情况下，不使用 ulValue。</td></tr><tr><td align="center">eSetBits</td><td align="center">目标任务的通知值 使用 ulValue 按位或运算</td></tr><tr><td align="center">eIncrement</td><td align="center">目标任务的通知值自增 1（类似信号量的 give 操作）</td></tr><tr><td align="center">eSetValueWithOverwrite</td><td align="center">目标任务的通知值 无条件设置为 ulValue。</td></tr><tr><td align="center">eSetValueWithoutOrwrite</td><td align="center">如果目标任务没有 挂起的通知，则其通知值 将设置为 ulValue。如果目标任务已经有 挂起的通知，则不会更新其通知值。</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待接收任务通知</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyWait</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> ulBitsToClearOnEntry, <span class="comment">//进入函数清除的通知值位</span></span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> ulBitsToClearOnExit,<span class="comment">//退出函数清除的通知值位</span></span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> *pulNotificationValue, <span class="comment">//通知值</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//等待时长</span></span><br></pre></td></tr></table></figure><p><strong>示例代码如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/event_groups.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要使用任务通知，需要记录任务句柄</span></span><br><span class="line"><span class="type">static</span> TaskHandle_t s_notifyTaskAHandle;</span><br><span class="line"><span class="type">static</span> TaskHandle_t s_notifyTaskBHandle;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 任务通知A，用于定时向任务通知B直接传输数据</span></span><br><span class="line"><span class="comment"> * @param 无</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">notify_taskA</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> rec_val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (xTaskNotifyWait(<span class="number">0x00</span>, ULONG_MAX, &amp;rec_val, pdMS_TO_TICKS(<span class="number">1000</span>)) == pdTRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG,<span class="string">&quot;receive notify value:%lu&quot;</span>,rec_val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 任务通知B，实时接收任务通知A的数据</span></span><br><span class="line"><span class="comment"> * @param 无</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">notify_taskB</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> notify_val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xTaskNotify(s_notifyTaskAHandle, notify_val, eSetValueWithOverwrite);</span><br><span class="line">        notify_val++;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 任务通知例程初始化</span></span><br><span class="line"><span class="comment"> * @param 无</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtos_notify_sample</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    xTaskCreatePinnedToCore(notify_taskA,<span class="string">&quot;notify_taskA&quot;</span>,<span class="number">2048</span>,<span class="literal">NULL</span>,<span class="number">3</span>,&amp;s_notifyTaskAHandle,<span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(notify_taskB,<span class="string">&quot;notify_taskB&quot;</span>,<span class="number">2048</span>,<span class="literal">NULL</span>,<span class="number">3</span>,&amp;s_notifyTaskBHandle,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LVGL移植"><a href="#LVGL移植" class="headerlink" title="LVGL移植"></a>LVGL移植</h1><h2 id="拉取相关源码"><a href="#拉取相关源码" class="headerlink" title="拉取相关源码"></a>拉取相关源码</h2><p>在github网站上拉取相关的源码，在终端下执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> <span class="built_in">clone</span> --recursive https://github.com/lvgl/lvgl.git</span><br></pre></td></tr></table></figure><p>其中<code>--recursive</code>这是一个可选参数，它告诉Git在克隆主仓库的同时，也递归地克隆所有子模块。如果你的项目使用了Git子模块来引用其他项目，那么你需要使用这个参数来确保所有子模块也都被正确地克隆下来。<br>由于LVGL包含很多的版本，使用指令查看包含的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> tag</span><br></pre></td></tr></table></figure><p>按<code>q</code>退出查看，使用指令切换需要的版本v8.3.10：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> checkout v8.3.10</span><br></pre></td></tr></table></figure><h2 id="添加屏幕驱动"><a href="#添加屏幕驱动" class="headerlink" title="添加屏幕驱动"></a>添加屏幕驱动</h2><p>将驱动文件<code>st7789_driver.c</code>和<code>cst816t_driver.c</code>添加到components文件夹下，并添加<code>CMakeLists.txt</code>。内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">idf_component_register(</span><br><span class="line">    SRCS <span class="string">&quot;st7789_driver.c&quot;</span> <span class="string">&quot;cst816t_driver.c&quot;</span>   //添加相关文件</span><br><span class="line">    INCLUDE_DIRS    <span class="string">&quot;.&quot;</span>                         //添加相关路径为当前路径</span><br><span class="line">    REQUIRES    esp_lcd                         //导入依赖</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="链接lvgl接口"><a href="#链接lvgl接口" class="headerlink" title="链接lvgl接口"></a>链接lvgl接口</h2><p>链接lvgl接口步骤如下：</p><ol><li>初始化和注册LVGL显示驱动</li><li>初始化和注册LVGL触摸驱动</li><li>初始化ST7789硬件接口</li><li>初始化CST816T硬件接口</li><li>提供一个定时器给LVGL使用，作为心跳</li></ol><p>在main目录下添加文件<code>lv_port.c</code>和<code>lv_port.h</code>用于链接lvgl。内容如下：<br><strong>lv_port.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lvgl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;st7789_driver.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cst816t_driver.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driver/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.初始化和注册LVGL显示驱动</span></span><br><span class="line"><span class="comment">2.初始化和注册LVGL触摸驱动</span></span><br><span class="line"><span class="comment">3.初始化ST7789硬件接口</span></span><br><span class="line"><span class="comment">4.初始化CST816T硬件接口</span></span><br><span class="line"><span class="comment">5.提供一个定时器给LVGL使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAG     <span class="string">&quot;lv_port&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_WIDTH       240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_HEIGHT      280</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">lv_disp_drv_t</span>    disp_drv;<span class="comment">//显示驱动变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_flush_done_cb</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">    lv_disp_flush_ready(&amp;disp_drv);<span class="comment">//写入完成通知</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">disp_flush</span><span class="params">(<span class="keyword">struct</span> <span class="type">_lv_disp_drv_t</span> * disp_drv, <span class="type">const</span> <span class="type">lv_area_t</span> * area, <span class="type">lv_color_t</span> * color_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    st7789_flush(area-&gt;x1,area-&gt;x2 + <span class="number">1</span>,area-&gt;y1+<span class="number">20</span>,area-&gt;y2+<span class="number">20</span> + <span class="number">1</span>,color_p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_disp_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">lv_disp_draw_buf_t</span>   disp_buf;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> disp_buf_size = LCD_WIDTH*(LCD_HEIGHT/<span class="number">7</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不能使用C语言的malloc函数</span></span><br><span class="line">    <span class="type">lv_color_t</span> *disp1 = heap_caps_malloc(disp_buf_size*<span class="keyword">sizeof</span>(<span class="type">lv_color_t</span>),MALLOC_CAP_INTERNAL|MALLOC_CAP_DMA);<span class="comment">//MALLOC_CAP_INTERNAL表示从内部ram中申请   MALLOC_CAP_DMA表示需要使用DMA传输</span></span><br><span class="line">    <span class="type">lv_color_t</span> *disp2 = heap_caps_malloc(disp_buf_size*<span class="keyword">sizeof</span>(<span class="type">lv_color_t</span>),MALLOC_CAP_INTERNAL|MALLOC_CAP_DMA);</span><br><span class="line">    <span class="keyword">if</span>(!disp1 || !disp2)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG,<span class="string">&quot;disp buff malloc fail!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lv_disp_draw_buf_init(&amp;disp_buf,disp1,disp2,disp_buf_size);<span class="comment">//双缓存</span></span><br><span class="line"></span><br><span class="line">    lv_disp_drv_init(&amp;disp_drv);<span class="comment">//初始化显示成员</span></span><br><span class="line"></span><br><span class="line">    disp_drv.hor_res = LCD_WIDTH;</span><br><span class="line">    disp_drv.ver_res = LCD_HEIGHT;</span><br><span class="line">    disp_drv.draw_buf = &amp;disp_buf;</span><br><span class="line">    disp_drv.flush_cb = disp_flush;<span class="comment">//显示函数指针</span></span><br><span class="line">    lv_disp_drv_register(&amp;disp_drv);<span class="comment">//将显示驱动注册</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> IRAM_ATTR <span class="title function_">indev_read</span><span class="params">(<span class="keyword">struct</span> <span class="type">_lv_indev_drv_t</span> * indev_drv, <span class="type">lv_indev_data_t</span> * data)</span><span class="comment">//触摸接口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int16_t</span> x,y;</span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line">    cst816t_read(&amp;x,&amp;y,&amp;state);</span><br><span class="line">    data-&gt;point.x = x;</span><br><span class="line">    data-&gt;point.y = y;</span><br><span class="line">    data-&gt;state = state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_indev_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//注册输入驱动</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">lv_indev_drv_t</span> indev_drv;</span><br><span class="line">    lv_indev_drv_init(&amp;indev_drv);</span><br><span class="line">    indev_drv.type = LV_INDEV_TYPE_POINTER;<span class="comment">//输入方式--触摸</span></span><br><span class="line">    indev_drv.read_cb = indev_read;<span class="comment">//触摸函数指针</span></span><br><span class="line">    lv_indev_drv_register(&amp;indev_drv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">st7789_hw_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//初始化LCD硬件接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">st7789_cfg_t</span> st7789_config = &#123;</span><br><span class="line">        .cs = GPIO_NUM_39,</span><br><span class="line">        .bl = GPIO_NUM_45,</span><br><span class="line">        .dc = GPIO_NUM_38,</span><br><span class="line">        .clk = GPIO_NUM_18,</span><br><span class="line">        .mosi = GPIO_NUM_19,</span><br><span class="line">        .rst = GPIO_NUM_47,</span><br><span class="line">        .spi_fre = <span class="number">40</span>*<span class="number">1000</span>*<span class="number">1000</span>,</span><br><span class="line">        .height = LCD_HEIGHT,</span><br><span class="line">        .width = LCD_WIDTH,</span><br><span class="line">        .spin = <span class="number">0</span>,</span><br><span class="line">        .done_cb = lv_flush_done_cb,</span><br><span class="line">        .cb_param = &amp;disp_drv,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    st7789_driver_hw_init(&amp;st7789_config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cst816t_hw_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//初始化触摸硬件接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cst816t_cfg_t</span> cst816t_config = </span><br><span class="line">    &#123;</span><br><span class="line">        .scl = GPIO_NUM_10,</span><br><span class="line">        .sda = GPIO_NUM_11,</span><br><span class="line">        .fre = <span class="number">300</span>*<span class="number">1000</span>,</span><br><span class="line">        .x_limit = LCD_WIDTH,</span><br><span class="line">        .y_limit = LCD_HEIGHT,</span><br><span class="line">    &#125;;</span><br><span class="line">    cst816t_init(&amp;cst816t_config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_timer_cb</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> tick_interval = *((<span class="type">uint32_t</span>*)arg);</span><br><span class="line">    lv_tick_inc(tick_interval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_tick_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//初始化定时器</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> tick_interval = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">esp_timer_create_args_t</span> arg = </span><br><span class="line">    &#123;</span><br><span class="line">        .arg = &amp;tick_interval,</span><br><span class="line">        .callback = lv_timer_cb,<span class="comment">//回调函数</span></span><br><span class="line">        .name = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        .dispatch_method = ESP_TIMER_TASK,</span><br><span class="line">        .skip_unhandled_events = <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">esp_timer_handle_t</span> timer_handle;</span><br><span class="line">    esp_timer_create(&amp;arg,&amp;timer_handle);</span><br><span class="line">    esp_timer_start_periodic(timer_handle,tick_interval*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_port_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lv_init();</span><br><span class="line">    st7789_hw_init();</span><br><span class="line">    cst816t_hw_init();</span><br><span class="line">    lv_disp_init();</span><br><span class="line">    lv_indev_init();</span><br><span class="line">    lv_tick_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lv_port.h</strong></p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LV_PORT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LV_PORT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_port_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="修改ESP32配置文件"><a href="#修改ESP32配置文件" class="headerlink" title="修改ESP32配置文件"></a>修改ESP32配置文件</h2><p>在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py menuconfig</span><br></pre></td></tr></table></figure><ol><li><p>配置flash<br> Serial flasher configuration —&gt; Flash size —&gt; 8MB (32Mb)</p></li><li><p>打开psram<br>Component config —&gt; ESP PSRAM  </p></li><li><p>修改CUP频率<br>Component config —&gt; ESP32 System Settings —&gt; CPU frequency —&gt; 240MHz</p></li><li><p>配置LVGL<br>Component config —&gt; LVGL configuration —&gt; Color setings —&gt; Swap the 2 bytes of RGB565 color.<br>Component config —&gt; LVGL configuration —&gt; Memory settings —&gt; If ture use custom malloc&#x2F;free.&#x2F;&#x2F;将空间放置于psram中</p></li></ol><h1 id="ESP32基础外设"><a href="#ESP32基础外设" class="headerlink" title="ESP32基础外设"></a>ESP32基础外设</h1><h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><h1 id="ESP32开发小坑"><a href="#ESP32开发小坑" class="headerlink" title="ESP32开发小坑"></a>ESP32开发小坑</h1><h2 id="自带rtos延时函数不准问题"><a href="#自带rtos延时函数不准问题" class="headerlink" title="自带rtos延时函数不准问题"></a>自带rtos延时函数不准问题</h2><p> vTaskDelay();函数使用时，要想做到延时确定的时间，需要注意使用portTICK_PERIOD_MS宏进行tick时间转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vTaskDelay(<span class="number">1000</span>/portTICK_PERIOD_MS);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vTaskDelay(pdMS_TO_TICKS(<span class="number">500</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>新文章编写指南</title>
      <link href="/2024/11/18/%E6%96%B0%E6%96%87%E7%AB%A0%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/"/>
      <url>/2024/11/18/%E6%96%B0%E6%96%87%E7%AB%A0%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="兴建Hexo的Markdown博客文章"><a href="#兴建Hexo的Markdown博客文章" class="headerlink" title="兴建Hexo的Markdown博客文章"></a>兴建Hexo的Markdown博客文章</h1><p>在根文件夹打开 git bash 输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;文章名称&quot;</span></span><br></pre></td></tr></table></figure><p>注意必须要输入引号，否则会报错。在<code>\source\_posts</code>目录下会生成一个.md文件,文章可在该文件内编写。</p><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p>具体完整的内容可以查看<a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程</a> 本文章主要记录一些常用的Markdown语法。</p><h2 id="文案标题"><a href="#文案标题" class="headerlink" title="文案标题"></a>文案标题</h2><p>Markdown 标题有两种格式。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">一级标题</span></span><br><span class="line"><span class="section">=================</span></span><br><span class="line"></span><br><span class="line"><span class="section">二级标题</span></span><br><span class="line"><span class="section">-----------------</span></span><br></pre></td></tr></table></figure><p>该方法 <code>=</code> 和 <code>-</code> 的个数可以随意，但是不常用。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><p>该方法较为常用，但是要注意<code>#</code>的后面一定要加上空格<code> </code>否则语法不起作用。</p><h2 id="嵌入代码"><a href="#嵌入代码" class="headerlink" title="嵌入代码"></a>嵌入代码</h2><p>在文字段中加入编码可以使用两个符号“ &#96; ”来包裹，该符号位于键盘的 <kbd>esc</kbd> 键下面。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`printf(&quot;Hello World!&quot;)`</span></span><br></pre></td></tr></table></figure><p>Markdown效果：<code>printf(&quot;Hello World!&quot;)</code><br>当代码量相对较大时，可以使用两个<code>```</code>来包裹。第一个<code>```</code>后面可以加入语言名，如<code>C</code>，这样Markdown就会根据语言名高亮显示。编码如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\ <span class="code">```C</span></span><br><span class="line"><span class="code"> #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"> int main(int argc, char *argv[], char *envp[])</span></span><br><span class="line"><span class="code"> &#123;</span></span><br><span class="line"><span class="code">     printf(&quot;Hello World!\n&quot;);</span></span><br><span class="line"><span class="code">     return 0;</span></span><br><span class="line"><span class="code"> &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"> \```</span></span><br></pre></td></tr></table></figure><p>Markdown效果,可见语法已经被高亮显示了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h2><p>Markdown可以将链接嵌入文字中<code>[链接名称](链接地址)</code>，此时只显示链接中的链接名称，点击链接可以跳转到链接地址，举例如下。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">Fred&#x27;s Blog</span>](<span class="link">https://jasting10.github.io/</span>)</span><br></pre></td></tr></table></figure><p>效果如下:<a href="https://jasting10.github.io/">Fred’s Blog</a></p><p>当然也可以直接显示出需要跳转的链接，可以使用 <code>&lt;链接地址&gt;</code> 举例如下。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">&lt;https://jasting10.github.io/&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下:<a href="https://jasting10.github.io/">https://jasting10.github.io/</a></p><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>图片语法格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">alt 属性文本</span>](<span class="link">图片地址</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">alt 属性文本</span>](<span class="link">图片地址 &quot;可选标题&quot;</span>)</span><br></pre></td></tr></table></figure><p>可见该语法和嵌入链接的语法相似，举例如下。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">hummingbird.jpeg</span>](<span class="link">https://s2.loli.net/2024/11/14/s6jWuxrelG8Y52Z.jpg</span>)</span><br></pre></td></tr></table></figure><p>效果如下:<br><img src="https://s2.loli.net/2024/11/14/s6jWuxrelG8Y52Z.jpg" width="50%"><br>Markdown还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code>标签。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s2.loli.net/2024/11/14/s6jWuxrelG8Y52Z.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果如下,图像缩小长宽均50%:<br><img src="https://s2.loli.net/2024/11/14/s6jWuxrelG8Y52Z.jpg" width="25%"></p><h2 id="文字编辑"><a href="#文字编辑" class="headerlink" title="文字编辑"></a>文字编辑</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>Markdown 可以使用以下几种字体：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本*</span>**</span></span><br><span class="line"><span class="strong">__<span class="emphasis">_粗斜体文本_</span>__</span></span><br></pre></td></tr></table></figure><p>效果如下：<br><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线可以通过 HTML 的 <code>&lt;u&gt;</code> 标签来实现：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>带下划线文本<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果如下：<u>带下划线文本</u></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~BAIDU.COM~~</span><br></pre></td></tr></table></figure><p>效果如下：<del>BAIDU.COM</del></p><p><strong><strong>后续如用到新语法会继续更新文章</strong></strong></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
