<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C嘎嘎学习笔记</title>
      <link href="/2025/01/13/C%E5%98%8E%E5%98%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/01/13/C%E5%98%8E%E5%98%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p><code>std</code> 是C++的标准命名空间，它是一个定义在 C++ 标准库中的所有类、函数和变量的命名空间。使用方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>自定义命名空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cir &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">double</span> PI = <span class="number">3.145926</span>;</span><br><span class="line">    <span class="comment">/*获取周长*/</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get_L</span><span class="params">(<span class="type">double</span> R)</span></span>;</span><br><span class="line">    <span class="comment">/*获取面积*/</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get_S</span><span class="params">(<span class="type">double</span> R)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中在 C++ 中，如果你想在命名空间内定义一个常量（如 <code>PI</code>），通常需要使用 <code>const</code> 关键字或者将其定义为 <code>constexpr</code>（C++11 及以上版本）。直接使用 <code>double PI = 3.14;</code> 在命名空间中是不合法的，因为命名空间不支持直接初始化变量。你需要使用 <code>const</code> 或 <code>constexpr</code>。</p><p>接下载需要具体化函数内容有两种写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cir.h&quot;</span></span></span><br><span class="line"><span class="comment">/*写法1*/</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cir::get_L</span><span class="params">(<span class="type">double</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> R*<span class="number">2</span>*cir::PI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cir::get_S</span><span class="params">(<span class="type">double</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> R*R*cir::PI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*写法2*/</span></span><br><span class="line"><span class="keyword">namespace</span> cir &#123;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get_L</span><span class="params">(<span class="type">double</span> R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> R*<span class="number">2</span>*cir::PI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get_S</span><span class="params">(<span class="type">double</span> R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> R*R*cir::PI;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>std包含的内容</strong></p><p><code>std</code>命名空间包含了许多类、函数和对象，例如：</p><ul><li><p>输入输出库（如<code>std::cout , std::cin , std::endl</code>）</p></li><li><p>容器类（如<code>std::vector , std::map , std::set</code>）</p></li><li><p>字符串类（<code>std::string</code>）</p></li><li><p>异常类（<code>std::exception</code>和相关子类）</p></li><li><p>算法（如<code>std::sort , std::find</code>）</p></li><li><p>实用工具（如<code>std::pair , std::tuple</code>）</p></li><li><p>其他许多功能</p></li></ul><p><strong>使用建议</strong></p><p>对于小型代码或示例代码，使用<code>using namespace std;</code> 通常是安全的。对于大型项目或库，建议显式地使用<code>std::</code> 前缀，以避免潜在的名称冲突，并提高代码的可读性和可维护性。<code>std</code>命名空间是 C++ 编程的基础部分，理解和正确使用它对于编写健壮和高效的 C++ 代码至关重要。</p><h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><p>C++ 中的输入和输出(I&#x2F;O)主要是通过标准库中的输入输出流来实现的。最常用的是<code>iostream</code>库，它</p><p>提供了用于输入和输出的基本流类，包括<code>cin</code>、<code>cout</code>、<code>cerr</code>和<code>clog</code>。</p><p>基本使用输出流如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; <span class="string">&quot;woeld&quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输入(箭头指向数据的方向)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cin &gt;&gt; i;</span><br></pre></td></tr></table></figure><p><strong>标准错误流</strong> <strong>(</strong><code>cerr</code>) <strong>和标准日志流</strong> <strong>(</strong> <code>clog</code>)</p><p><code>cerr</code>用于输出错误消息。与<code>cout</code>不同，<code>cerr</code>不是缓冲的，这意味着它会立即输出。</p><p><code>clog</code>类似于<code>cerr</code>，但它是缓冲的。它通常用于记录错误和日志信息。</p><h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><p>C++中可以直接使用<code>bool</code>类型的数据，包含<code>true</code>,<code>false</code>值。</p><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>内联函数（Inline Function）是C++中一种特殊的函数，其定义直接在每个调用点展开。这意味着编译器会将函数调用<strong>替换</strong>为函数本身的代码，这样可以减少函数调用的开销，尤其是在小型函数中。主要作用为提升代码的可读性。<strong>关键字 <code>inline</code> 必须与函数定义体放在一起才能使函数成为内联</strong>。在函数声明处添加 <code>inline</code> 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 <code>inline</code> 关键字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i+j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lambda匿名函数"><a href="#Lambda匿名函数" class="headerlink" title="Lambda匿名函数"></a>Lambda匿名函数</h1><p>Lambda 表达式是 C++11 引入的一种匿名函数的方式，<strong>它允许你在需要函数的地方内联地定义函数，而无需单独命名函数。</strong>相较于普通非匿名函数，匿名函数无需进行另外的声明和定义，仅当调用该匿名时，函数体才会创建，且调用完毕后会立即释放资源。因此匿名函数会更加节省空间，常用于像<code>std::sort</code>这样可以重写排序方式的函数。Lambda表达式基本语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  捕获列表         参数          返回值类型</span></span><br><span class="line">[capture clause](parameters) -&gt; return_type&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">    <span class="comment">//可以使用捕获列表中的参数</span></span><br><span class="line">    <span class="keyword">return</span> expression;<span class="comment">//可选返回语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda 表达式由以下部分组成：</p><ul><li><p><strong>捕获列表（Capture clause</strong>：用于捕获外部变量，在 Lambda 表达式中可以访问这些变量。捕获列表可以为空，也可以包含变量列表<code>[var1, var2, ...]</code>。</p></li><li><p><strong>参数列表（Parameters）</strong>：与普通函数的参数列表类似，可以为空或包含参数列表<code>(param1,param2, ...)</code>。</p></li><li><p><strong>返回类型（Return type）</strong>：Lambda表达式可以自动推断返回类型auto，也可以显式指定返回类型 -&gt; return_type 。如果函数体只有一条返回语句，可以省略返回类型。</p></li><li><p><strong>函数体（Body）</strong>：Lambda 表达式的函数体，包含需要执行的代码。</p></li></ul><p>匿名函数的使用例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子1：</span></span><br><span class="line"><span class="keyword">auto</span> testReturn = [](<span class="type">int</span> a1, <span class="type">int</span> a2) &#123;<span class="keyword">return</span> a1&gt;a2 &#125;;</span><br><span class="line"><span class="type">bool</span> flag = <span class="built_in">testReturn</span>(<span class="number">23</span>, <span class="number">21</span>);</span><br><span class="line">cout&lt;&lt;flag&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子2：</span></span><br><span class="line"><span class="type">int</span> as = <span class="number">100</span>；</span><br><span class="line"><span class="keyword">auto</span> testReturn = [](<span class="type">int</span> a1, <span class="type">int</span> a2) &#123;<span class="keyword">return</span> a1&gt;a2 &#125;;</span><br><span class="line"><span class="type">bool</span> flag = <span class="built_in">testReturn</span>(as, <span class="number">21</span>);</span><br><span class="line">cout&lt;&lt;flag&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子3：</span></span><br><span class="line"><span class="type">int</span> as = <span class="number">100</span>；</span><br><span class="line"><span class="keyword">auto</span> testReturn = [&amp;](<span class="type">int</span> a1, <span class="type">int</span> a2) &#123;a1 = <span class="number">10</span>； <span class="keyword">return</span> a1&gt;a2 &#125;;</span><br><span class="line"><span class="type">bool</span> flag = <span class="built_in">testReturn</span>(as, <span class="number">21</span>);</span><br><span class="line">cout&lt;&lt;flag&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;as&lt;&lt;endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>重点：</strong>区分<code>auto add = [=](int a1, int a2) &#123;return a1+a2 &#125;;</code>和<code>auto add = [&amp;](int a1, int a2) &#123;return a1+a2 &#125;</code>。其中的区别主要为<code>[=]</code>和<code>[&amp;]</code>,其中<code>[=]</code>表示按<strong>数值</strong>传入上方所用的变量，其中<code>[&amp;]</code>表示按<strong>引用</strong>传入上方所用的变量。按<strong>数值</strong>传入的变量只可以访问不能修改，按<strong>引用</strong>传入的变量可以访问并且修改。</p><p>Lambda还有一个重要的作用就是<strong>把自身当作回调函数的参数</strong>，演示代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_best</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">bool</span> (*compare)(<span class="type">int</span> a, <span class="type">int</span> b))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">compare</span>(a, b))<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">get_best</span>(<span class="number">12</span>, <span class="number">34</span>, [](<span class="type">int</span> a,<span class="type">int</span> b)-&gt;<span class="type">bool</span>&#123;<span class="keyword">if</span>(a&lt;b)<span class="keyword">return</span> <span class="literal">true</span>; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;&#125;) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用该方法可以快速的编写回调函数。</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的概念是面向对象编程的核心之一，其主要目的是将<strong>数据和与数据相关的操作</strong>封装在一起。</p><p>C++ 类的基本结构通常包含：</p><ol><li><p><strong>数据成员（Attributes）</strong>：定义类的属性。这些是类内部的变量，用于存储对象的状态。</p></li><li><p><strong>成员函数（Methods）</strong>：定义类的行为。这些是可以操作对象的数据成员的函数。</p></li><li><p><strong>构造函数和析构函数</strong>：特殊的成员函数。构造函数在创建对象时自动调用，用于初始化对象。析构函数在对象销毁时调用，用于执行清理操作。</p></li><li><p><strong>访问修饰符</strong>：如<code>public , private , protected</code>用于控制对类成员的访问权限。例如，<code>public</code>成员可以在类的外部访问，而<code>private</code>成员只能在类内部访问。</p></li><li><p><strong>继承</strong>：允许一个类继承另一个类的特性。这是代码重用和多态性的关键。通过这些特性，C++ 类提供了一种强大的方式来组织和处理数据，使得代码更加模块化、易于理解和维护。</p></li></ol><p>类的使用示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义汽车类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">car</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string color;</span><br><span class="line">    std::string brand;</span><br><span class="line">    std::string type;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义函数指针，指向介绍函数</span></span><br><span class="line">    <span class="built_in">void</span> (*PrintCarInfo)(std::string color, std::string brand, std::string type, <span class="type">int</span> year);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BWM</span><span class="params">(std::string color, std::string brand, std::string type, <span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;color:&quot;</span> + color</span><br><span class="line">               + <span class="string">&quot; brand:&quot;</span> + brand</span><br><span class="line">               + <span class="string">&quot; type:&quot;</span> + type</span><br><span class="line">               + <span class="string">&quot; year:&quot;</span> + std::<span class="built_in">to_string</span>(year);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AOD</span><span class="params">(std::string color, std::string brand, std::string type, <span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;color:&quot;</span> + color</span><br><span class="line">               + <span class="string">&quot; brand:&quot;</span> + brand</span><br><span class="line">               + <span class="string">&quot; type:&quot;</span> + type</span><br><span class="line">               + <span class="string">&quot; year:&quot;</span> + std::<span class="built_in">to_string</span>(year);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*以数值直接定义的方法*/</span></span><br><span class="line">    car a1;</span><br><span class="line">    a<span class="number">1.</span>type = <span class="string">&quot;A1&quot;</span>;</span><br><span class="line">    a<span class="number">1.</span>brand = <span class="string">&quot;BWM&quot;</span>;</span><br><span class="line">    a<span class="number">1.</span>color = <span class="string">&quot;RED&quot;</span>;</span><br><span class="line">    a<span class="number">1.</span>year = <span class="number">2020</span>;</span><br><span class="line">    a<span class="number">1.</span>PrintCarInfo = BWM;</span><br><span class="line"></span><br><span class="line">    a<span class="number">1.</span><span class="built_in">PrintCarInfo</span>(a<span class="number">1.</span>color, a<span class="number">1.</span>brand, a<span class="number">1.</span>type, a<span class="number">1.</span>year);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*以指针定义的方法*/</span></span><br><span class="line">    car *Q7;</span><br><span class="line">    Q7 = <span class="keyword">new</span> <span class="built_in">car</span>();</span><br><span class="line">    Q7-&gt;type = <span class="string">&quot;Q7&quot;</span>;</span><br><span class="line">    Q7-&gt;brand = <span class="string">&quot;AOD&quot;</span>;</span><br><span class="line">    Q7-&gt;color = <span class="string">&quot;BLACK&quot;</span>;</span><br><span class="line">    Q7-&gt;year = <span class="number">2018</span>;</span><br><span class="line">    Q7-&gt;PrintCarInfo = AOD;</span><br><span class="line"></span><br><span class="line">    Q7-&gt;<span class="built_in">PrintCarInfo</span>(Q7-&gt;color, Q7-&gt;brand, Q7-&gt;type, Q7-&gt;year);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码使用函数指针的方式传递函数，实际上还是C语言的方式。以下将展示C++类当中如何定义成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义汽车类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">car</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string color;</span><br><span class="line">    std::string brand;</span><br><span class="line">    std::string type;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义函数指针，指向介绍函数但是本质上仍然为变量不是函数</span></span><br><span class="line">    <span class="built_in">void</span> (*PrintCarInfo)(std::string color, std::string brand, std::string type, <span class="type">int</span> year);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义真正的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RealPrintCarInfo1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string str = <span class="string">&quot;color:&quot;</span> + color</span><br><span class="line">                   + <span class="string">&quot; brand:&quot;</span> + brand</span><br><span class="line">                   + <span class="string">&quot; type:&quot;</span> + type</span><br><span class="line">                   + <span class="string">&quot; year:&quot;</span> + std::<span class="built_in">to_string</span>(year);</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RealPrintCarInfo2</span><span class="params">()</span></span>;<span class="comment">//申明成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">car::RealPrintCarInfo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;color:&quot;</span> + color</span><br><span class="line">               + <span class="string">&quot; brand:&quot;</span> + brand</span><br><span class="line">               + <span class="string">&quot; type:&quot;</span> + type</span><br><span class="line">               + <span class="string">&quot; year:&quot;</span> + std::<span class="built_in">to_string</span>(year);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然一个类可以包含一个类。在 C++中，一个类包含另一个类的对象称为组合（Composition）。这是一种常见的设计模式，用于表示一个类是由另一个类的对象组成的。这种关系通常表示一种”拥有”（”has-a”）的关系。</p><p>普通变量访问成员变量或者成员函数，使用 “<code>.</code>” 运算符</p><p>指针变量访问成员变量或者成员函数，使用“<code>-&gt;</code>”运算符，像C语言的结构体用法</p><p>示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wheel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string brand;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wheelPrintInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Wheel::wheelPrintInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我的轮胎品牌是：&quot;</span> &lt;&lt; brand &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我的轮胎日期是：&quot;</span> &lt;&lt; year &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在 C++中，一个类包含另一个类的对象称为组合（Composition）。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123; <span class="comment">//汽车“类”</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//成员数据</span></span><br><span class="line">    string color; <span class="comment">//颜色</span></span><br><span class="line">    string brand; <span class="comment">//品牌</span></span><br><span class="line">    string type; <span class="comment">//车型</span></span><br><span class="line">    <span class="type">int</span> year; <span class="comment">//年限</span></span><br><span class="line">    Wheel wl;</span><br><span class="line">    Wheel *pwl;</span><br><span class="line">    <span class="comment">//其实也是成员数据，指针变量，指向函数的变量，并非真正的成员函数</span></span><br><span class="line">    <span class="built_in">void</span> (*printCarInfo)(string color,string brand,string type, <span class="type">int</span> year); <span class="comment">//函数</span></span><br><span class="line">    指针，指向车介绍函数</span><br><span class="line">    <span class="built_in">void</span> (*carRun)(string type); <span class="comment">//函数指针，指向车运行的函数</span></span><br><span class="line">    <span class="built_in">void</span> (*carStop)(string type); <span class="comment">//函数指针，执行车停止的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">realPrintCarInfo</span><span class="params">()</span></span>;<span class="comment">//声明成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Car::realPrintCarInfo</span><span class="params">()</span> <span class="comment">//在类的外部进行成员函数的实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;车的品牌是：&quot;</span> + brand</span><br><span class="line">                + <span class="string">&quot;,型号是: &quot;</span> + type</span><br><span class="line">                + <span class="string">&quot;,颜色是：&quot;</span> + color</span><br><span class="line">                + <span class="string">&quot;,上市年限是:&quot;</span> + std::<span class="built_in">to_string</span>(year);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bwmThreePrintCarInfo</span><span class="params">(string color,string brand,string type, <span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;车的品牌是：&quot;</span> + brand</span><br><span class="line">                + <span class="string">&quot;,型号是: &quot;</span> + type</span><br><span class="line">                + <span class="string">&quot;,颜色是：&quot;</span> + color</span><br><span class="line">                + <span class="string">&quot;,上市年限是:&quot;</span> + std::<span class="built_in">to_string</span>(year);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A6PrintCarInfo</span><span class="params">(string color,string brand,string type, <span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;车的品牌是：&quot;</span> + brand</span><br><span class="line">                + <span class="string">&quot;,型号是: &quot;</span> + type</span><br><span class="line">                + <span class="string">&quot;,颜色是：&quot;</span> + color</span><br><span class="line">                + <span class="string">&quot;,上市年限是:&quot;</span> + std::<span class="built_in">to_string</span>(year);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Car BWMthree;</span><br><span class="line">    BWMthree.color = <span class="string">&quot;白色&quot;</span>;</span><br><span class="line">    BWMthree.brand = <span class="string">&quot;宝马&quot;</span>;</span><br><span class="line">    BWMthree.type = <span class="string">&quot;3系&quot;</span>;</span><br><span class="line">    BWMthree.year = <span class="number">2023</span>;</span><br><span class="line">    BWMthree.pwl = <span class="keyword">new</span> <span class="built_in">Wheel</span>();</span><br><span class="line">    BWMthree.pwl-&gt;brand = <span class="string">&quot;米其林&quot;</span>;</span><br><span class="line">    BWMthree.pwl-&gt;year = <span class="number">2023</span>;</span><br><span class="line">    <span class="comment">//BWMthree.wl.brand = &quot;米其林&quot;;</span></span><br><span class="line">    <span class="comment">//BWMthree.wl.year = 2023;</span></span><br><span class="line">    BWMthree.printCarInfo = bwmThreePrintCarInfo;</span><br><span class="line">    BWMthree.<span class="built_in">printCarInfo</span>(BWMthree.color,BWMthree.brand,BWMthree.type,BWMthree.year);</span><br><span class="line">    BWMthree.<span class="built_in">realPrintCarInfo</span>();</span><br><span class="line">    <span class="comment">//BWMthree.wl.wheelPrintInfo();</span></span><br><span class="line">    Car *AodiA6 = <span class="keyword">new</span> <span class="built_in">Car</span>();</span><br><span class="line">    <span class="comment">// AodiA6 = (struct Car*)malloc(sizeof(struct Car));</span></span><br><span class="line">    AodiA6-&gt;color = <span class="string">&quot;黑色&quot;</span>;</span><br><span class="line">    AodiA6-&gt;brand = <span class="string">&quot;奥迪&quot;</span>;</span><br><span class="line">    AodiA6-&gt;type = <span class="string">&quot;A6&quot;</span>;</span><br><span class="line">    AodiA6-&gt;year = <span class="number">2008</span>;</span><br><span class="line">    AodiA6-&gt;printCarInfo = A6PrintCarInfo;</span><br><span class="line">    AodiA6-&gt;pwl = <span class="keyword">new</span> Wheel;</span><br><span class="line">    AodiA6-&gt;pwl-&gt;brand = <span class="string">&quot;普利司通&quot;</span>;</span><br><span class="line">    AodiA6-&gt;pwl-&gt;year = <span class="number">2012</span>;</span><br><span class="line">    <span class="comment">//AodiA6-&gt;wl.brand = &quot;马牌&quot;;</span></span><br><span class="line">    <span class="comment">//AodiA6-&gt;wl.year = 2023;</span></span><br><span class="line">    AodiA6-&gt;<span class="built_in">printCarInfo</span>(AodiA6-&gt;color,AodiA6-&gt;brand,AodiA6-&gt;type,AodiA6-&gt;year);</span><br><span class="line">    AodiA6-&gt;<span class="built_in">realPrintCarInfo</span>();</span><br><span class="line">    <span class="comment">//AodiA6-&gt;wl.wheelPrintInfo();</span></span><br><span class="line">    AodiA6-&gt;pwl-&gt;<span class="built_in">wheelPrintInfo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><p>C++中的访问权限主要分为三种：<code>public</code>、<code>private</code>和<code>protected</code>。这些权限决定了类成员（包括数</p><p>据成员和成员函数）的可访问性。以下是一个总结表格，说明了在不同情况下这些权限如何应用：</p><table><thead><tr><th align="center">访问权限</th><th align="center">类内部</th><th align="center">同一个类的对象</th><th align="center">派生类</th><th align="center">类外部</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">private</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">protected</td><td align="center">✅</td><td align="center">❌</td><td align="center">✅</td><td align="center">❌</td></tr></tbody></table><p>使用权限（如<code>public</code>、<code>private</code>和<code>protected</code>）在C++中是一种关键的封装手段，它们旨在控制对类成员的访问。下面是一个表格，总结了使用权限的主要好处和潜在缺点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">银行的账户是一个模板，是一个类，有存款人信息和账户额度，而具体的存款人视为一个对象，</span></span><br><span class="line"><span class="comment">一个对象不能私自修改账户额度，需要通过一个操作流程，比如去ATM或者柜台进行操作才能修改到账户额度，</span></span><br><span class="line"><span class="comment">所以，存款人信息和账户额度设计成私有权限，通过公有的操作流程，也就是公有函数去操作私有变量。</span></span><br><span class="line"><span class="comment">基于这个场景，我们编程实现代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//有存款人信息和账户额度</span></span><br><span class="line">    string name;</span><br><span class="line">    string addr;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string bankAddr;</span><br><span class="line"><span class="comment">//比如去ATM或者柜台进行操作才能修改到账户额度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">registerMes</span><span class="params">(string newName, string newAddr,<span class="type">int</span> newAge,<span class="type">double</span></span></span></span><br><span class="line"><span class="params"><span class="function">newBalance)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printUserInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BankAccount::printUserInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string mesTem = <span class="string">&quot;账户名：&quot;</span> + name + <span class="string">&quot;，地址：&quot;</span> + addr +</span><br><span class="line">    <span class="string">&quot;,年龄：&quot;</span>+ std::<span class="built_in">to_string</span>(age) + <span class="string">&quot;,存款：&quot;</span> + std::<span class="built_in">to_string</span>(balance);</span><br><span class="line">    cout &lt;&lt; mesTem &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BankAccount::registerMes</span><span class="params">(string newName, string newAddr,<span class="type">int</span> newAge,<span class="type">double</span></span></span></span><br><span class="line"><span class="params"><span class="function">newBalance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    name = newName;</span><br><span class="line">    addr = newAddr;</span><br><span class="line">    age = newAge;</span><br><span class="line">    balance = newBalance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 存款方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BankAccount::deposit</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    balance += amount;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Deposit amount must be positive.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取款方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BankAccount::withdraw</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount &gt; balance) &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Insufficient funds.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (amount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Withdrawal amount must be positive.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    balance -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取当前余额的方法</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">BankAccount::getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BankAccount user1;</span><br><span class="line">    user<span class="number">1.</span><span class="built_in">registerMes</span>(<span class="string">&quot;老陈&quot;</span>,<span class="string">&quot;深圳光明区&quot;</span>,<span class="number">35</span>,<span class="number">100</span>);</span><br><span class="line">    user<span class="number">1.</span><span class="built_in">printUserInfo</span>();</span><br><span class="line">    user<span class="number">1.</span><span class="built_in">deposit</span>(<span class="number">1000</span>);</span><br><span class="line">    cout &lt;&lt; user<span class="number">1.</span><span class="built_in">getBalance</span>() &lt;&lt; endl;</span><br><span class="line">    user<span class="number">1.</span><span class="built_in">withdraw</span>(<span class="number">30</span>);</span><br><span class="line">    cout &lt;&lt; user<span class="number">1.</span><span class="built_in">getBalance</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。在C语言中，一个数据对应一个内存，通过由一个变量名来访问这个内存空间的数据，叫做直接访问，相对直接访问，有个间接访问的说法，叫做指针。而引用<strong>相当于又给这个内存中的数据提供了一个新的变量名，这个变量名功能比传统变量名更特殊，是直达地址的，后续代码验证！</strong></p><p>以下代码通过使用引用变量作为参数，直接体现其直达地址的特性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = x; <span class="comment">/* 保存地址 x 的值 */</span></span><br><span class="line">    x = y; <span class="comment">/* 把 y 赋值给 x */</span></span><br><span class="line">    y = temp; <span class="comment">/* 把 x 赋值给 y */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量声明</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前，a 的值：&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前，b 的值：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/* 调用函数来交换值 */</span></span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后，a 的值：&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后，b 的值：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用引用来<strong>替代指针</strong>，会使 C++ 程序更容易阅读和维护。C++ 函数可以返回一个引用，方式与返回一个指针类似。当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，<strong>函数就可以放在赋值语句的左边。</strong>例如，请看下面这个简单的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">double</span> vals[] = &#123;<span class="number">10.1</span>, <span class="number">12.6</span>, <span class="number">33.1</span>, <span class="number">24.1</span>, <span class="number">50.0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">double</span>&amp; <span class="title">setValues</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span>&amp; ref = vals[i];</span><br><span class="line">    <span class="keyword">return</span> ref; <span class="comment">// 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要调用上面定义函数的主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;改变前的值&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;vals[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span>;</span><br><span class="line">        cout &lt;&lt; vals[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setValues</span>(<span class="number">1</span>) = <span class="number">20.23</span>; <span class="comment">// 改变第 2 个元素</span></span><br><span class="line">    <span class="built_in">setValues</span>(<span class="number">3</span>) = <span class="number">70.8</span>; <span class="comment">// 改变第 4 个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;改变后的值&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;vals[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span>;</span><br><span class="line">        cout &lt;&lt; vals[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">swap</span><span class="params">(<span class="type">int</span>* point, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp; ref = point[num];</span><br><span class="line">    <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(x, <span class="number">0</span>) = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; x[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><p><strong>函数重载</strong>在同一个作用域内，可以声明几个功能类似的<strong>同名函数</strong>，这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。下面的实例中，同名函数 <code>print()</code> 被用于输出不同的数据类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">show_data</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;int &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> a)</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;char &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;string &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;<span class="comment">//记得添加逗号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    show_data p;</span><br><span class="line">    p.<span class="built_in">print</span>(<span class="number">10086</span>);</span><br><span class="line">    p.<span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    p.<span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运算符重载</strong>在C++中，运算符重载是一个允许程序员自定义各种运算符（如 + , - , &#x3D;&#x3D; , !&#x3D; 等）在自定义类型（类或结构体）上的行为的特性。这意味着你可以定义类似于内置类型的运算符行为，使你的自定义类型更加直观和易于使用。</p><p><strong>基本原则</strong></p><ol><li><strong>不可以创建新的运算符</strong>：只能重载已经存在的运算符。</li><li><strong>至少有一个操作数是用户定义的类型</strong>：不能重载两个基本类型的运算符。</li><li><strong>不能更改运算符的优先级</strong>：重载的运算符保持其原有的优先级和结合性。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        point <span class="keyword">operator</span>+(point ptmp)<span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line">point point::<span class="keyword">operator</span>+(point ptmp)<span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    point ref;</span><br><span class="line">    ref.x = x+ptmp.x;</span><br><span class="line">    ref.y = y+ptmp.y;</span><br><span class="line">    <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    point p1,p2;</span><br><span class="line">    p<span class="number">1.</span>x = <span class="number">12</span>;</span><br><span class="line">    p<span class="number">1.</span>y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    p<span class="number">2.</span>x = <span class="number">34</span>;</span><br><span class="line">    p<span class="number">2.</span>y = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    point p3 = p1 + p2;</span><br><span class="line">    cout &lt;&lt; p<span class="number">3.</span>x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p<span class="number">3.</span>y &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中重载运算符需要使用<code>operator</code>关键字。后面添加<code>const</code>关键字可以保证被运算变量为常量，在计算过程中不被改变。</p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>类的构造函数是类的一种<strong>特殊的成员函数</strong>，它会在每次创建类的新对象时执行。构造的是<strong>构造成员变量的初始化值，内存空间等</strong>构造函数的名称与类的名称是完全相同的，并且<strong>不会返回任何类型，也不会返回 void</strong>。构造函数可用于为某些成员变量<strong>设置初始值</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">car</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       string brand;</span><br><span class="line">       <span class="type">int</span> year;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">car</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Class Init Success&quot;</span> &lt;&lt;endl;</span><br><span class="line">            brand = <span class="string">&quot;BWM&quot;</span>;</span><br><span class="line">            year = <span class="number">2021</span>;</span><br><span class="line">            cout &lt;&lt; brand &lt;&lt; year &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    car* p1;</span><br><span class="line">    p1 = <span class="keyword">new</span> <span class="built_in">car</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的构造函数没有任何参数，但如果需要，<strong>构造函数也可以带有参数</strong>。这样在创建对象时就会给对象赋初始值，如下面的例子所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">car</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       string brand;</span><br><span class="line">       <span class="type">int</span> year;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">car</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Class Init Success&quot;</span> &lt;&lt;endl;</span><br><span class="line">            brand = <span class="string">&quot;BWM&quot;</span>;</span><br><span class="line">            year = <span class="number">2021</span>;</span><br><span class="line">            cout &lt;&lt; brand &lt;&lt; year &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*使用构造函数实现同名操作，但是参数必须不同*/</span></span><br><span class="line">        <span class="built_in">car</span>(string B, <span class="type">int</span> Y)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Class Init Success&quot;</span> &lt;&lt;endl;</span><br><span class="line">            brand = B;</span><br><span class="line">            year = Y;</span><br><span class="line">            cout &lt;&lt; brand &lt;&lt; year &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    car* p1;</span><br><span class="line">    p1 = <span class="keyword">new</span> <span class="built_in">car</span>();</span><br><span class="line">    <span class="function">car <span class="title">p2</span><span class="params">(<span class="string">&quot;ODE&quot;</span>, <span class="number">2024</span>)</span></span>;</span><br><span class="line">    car* p3;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++中，使用<strong>初始化列表</strong>来初始化类的字段是一种高效的初始化方式，尤其在构造函数中。<strong>初始化列表直接在对象的构造过程中初始化成员变量</strong>，而不是先创建成员变量后再赋值。这对于<strong>提高性能</strong>尤其重要，特别是在涉及到复杂对象或引用和常量成员的情况下。初始化列表紧跟在构造函数参数列表后面，以冒号（<code>:</code>）开始，后跟一个或多个初始化表达式，每个表达式通常用逗号分隔。下面是使用初始化列表初始化字段的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">double</span> b;</span><br><span class="line">        std::string c;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 使用初始化列表来初始化字段</span></span><br><span class="line">        <span class="built_in">MyClass</span>(<span class="type">int</span> x, <span class="type">double</span> y, <span class="type">const</span> std::string&amp; z) : <span class="built_in">a</span>(x), <span class="built_in">b</span>(y), <span class="built_in">c</span>(z) &#123;</span><br><span class="line">        <span class="comment">// 构造函数体</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>MyClass</code>有三个成员变量：<code>a</code>（ int 类型）、<code>b</code>（ double 类型）和<code>c</code>（<code>std::string</code>类型）。当创建<code>MyClass</code>的一个实例时，我们通过构造函数传递三个参数，这些参数被用于通过初始化列表直接初始化成员变量。初始化列表<code>: a(x), b(y), c(z)</code>的意思是用<code>x</code>初始化<code>a</code>，用<code>y</code>初始化<code>b</code>，用<code>z</code>初始化<code>c</code>。初始化列表的优点包括：</p><ol><li><p><strong>效率</strong>：对于非基本类型的对象，使用初始化列表比在构造函数体内赋值更高效，因为它避免了先默认构造然后再赋值的额外开销。</p></li><li><p><strong>必要性</strong>：对于引用类型和常量类型的成员变量，必须使用初始化列表，因为这些类型的成员变量在构造函数体内不能被赋值。</p></li><li><p><strong>顺序</strong>：成员变量的初始化顺序是按照它们在类中声明的顺序，而不是初始化列表中的顺序。使用初始化列表是C++中推荐的初始化类成员变量的方式，因为它提供了更好的性能和灵活性。</p></li></ol><p>使用示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">car</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       string brand;</span><br><span class="line">       <span class="type">int</span> year;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">car</span>(string B):<span class="built_in">brand</span>(B),<span class="built_in">year</span>(<span class="number">2021</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Class Init Success&quot;</span> &lt;&lt;endl;</span><br><span class="line">            cout &lt;&lt; brand &lt;&lt; year &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    car* p3;</span><br><span class="line">    p3 = <span class="keyword">new</span> <span class="built_in">car</span>(<span class="string">&quot;Li&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p>析构函数是C++中的一个特殊的成员函数，它在对象生命周期结束时被自动调用，用于执行对象销毁前的清理工作。析构函数特别重要，尤其是在涉及动态分配的资源（如内存、文件句柄、网络连接等）的情况下。</p><p><strong>基本特性</strong></p><ol><li><p><strong>名称</strong>：析构函数的名称由波浪号（<code>~</code>）后跟类名构成，如<code>~MyClass()</code>。</p></li><li><p><strong>无返回值和参数</strong>：析构函数不接受任何参数，也不返回任何值。</p></li><li><p><strong>自动调用</strong>：当对象的生命周期结束时（例如，一个局部对象的作用域结束，或者使用<code>delete</code>删除一个动态分配的对象），析构函数会被自动调用。</p></li><li><p><strong>不可重载</strong>：每个类只能有一个析构函数。</p></li><li><p><strong>继承和多态</strong>：如果一个类是多态基类，其析构函数应该是虚的。</p></li></ol><p>代码示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span>* Data;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">my_class</span>(<span class="type">int</span> size)&#123;</span><br><span class="line">            Data = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*该函数为析构函数*/</span></span><br><span class="line">        ~<span class="built_in">my_class</span>()&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function has been used&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span>[] Data;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">my_class <span class="title">p1</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>在 C++ 中，<code>this</code>关键字是一个<strong>指向调用对象的指针</strong>。它在成员函数内部使用，用于引用调用该函数的对象。使用<code>this</code>可以明确指出成员函数正在操作的是哪个对象的数据成员。下面是一个使用<code>Car</code>类来展示<code>this</code>关键字用法的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">car</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       string brand;</span><br><span class="line">       string model;</span><br><span class="line">       <span class="type">int</span> year;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">car</span>(string A, string B, <span class="type">int</span> C)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;brand = A;</span><br><span class="line">            <span class="keyword">this</span>-&gt;model = B;</span><br><span class="line">            <span class="keyword">this</span>-&gt;year  = C;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">car::display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; brand &lt;&lt; model &lt;&lt; year &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">car <span class="title">p4</span><span class="params">(<span class="string">&quot;Tsla &quot;</span>, <span class="string">&quot;Modle Y &quot;</span>, <span class="number">2013</span>)</span></span>;</span><br><span class="line">    p<span class="number">4.</span><span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>this</code>指针可以实现<strong>链式调用</strong>操作。链式调用是一种编程风格，允许对象<strong>连续</strong>调用多个方法，每个方法都返回对象自身（<code>this</code>指针），从而可以继续调用下一个方法。这在C++中通常用在类设计时，特别是在构建者模式（Builder Pattern）和流式API设计中。以下是一个链式调用的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">car</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       string brand;</span><br><span class="line">       string model;</span><br><span class="line">       <span class="type">int</span> year;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">car</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Class Init Success&quot;</span> &lt;&lt;endl;</span><br><span class="line">            brand = <span class="string">&quot;BWM&quot;</span>;</span><br><span class="line">            year = <span class="number">2021</span>;</span><br><span class="line">            cout &lt;&lt; brand &lt;&lt; year &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">car&amp; <span class="title">setBrand</span><span class="params">(<span class="type">const</span> std::string&amp; b)</span> </span>&#123;</span><br><span class="line">            brand = b;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置型号并返回对象自身</span></span><br><span class="line">        <span class="function">car&amp; <span class="title">setModel</span><span class="params">(<span class="type">const</span> std::string&amp; m)</span> </span>&#123;</span><br><span class="line">            model = m;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置年份并返回对象自身</span></span><br><span class="line">        <span class="function">car&amp; <span class="title">setYear</span><span class="params">(<span class="type">int</span> y)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">car::display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; brand &lt;&lt; model &lt;&lt; year &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置年份并返回对象自身</span></span><br><span class="line"><span class="function">car&amp; <span class="title">car::setYear</span><span class="params">(<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    year = y;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用链式调用对对象进行操作</span></span><br><span class="line">    car p5;</span><br><span class="line">    p<span class="number">5.</span><span class="built_in">setBrand</span>(<span class="string">&quot;NBWM &quot;</span>).<span class="built_in">setModel</span>(<span class="string">&quot;X5 &quot;</span>).<span class="built_in">setYear</span>(<span class="number">2010</span>).<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h2><p>在C++中，<code>new</code>关键字用于动态分配内存。它是C++中处理动态内存分配的主要工具之一，允许在程序运行时根据需要分配内存。</p><p><strong>分配单个对象</strong>：使用<code>new</code>可以在堆上动态分配一个对象。例如，<code>new int</code>会分配一个<code>int</code>类型的空间，并返回一个指向该空间的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">//C语言中，int *p = (int *)malloc(sizeof(int));</span></span><br></pre></td></tr></table></figure><p><strong>分配对象数组</strong>：<code>new</code>也可以用来分配一个对象数组。例如，<code>new int[10]</code>会分配一个包含10个整数的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">//C语言中，int *arr = (int *)malloc(sizeof(int)*10);</span></span><br></pre></td></tr></table></figure><h2 id="delete关键字"><a href="#delete关键字" class="headerlink" title="delete关键字"></a>delete关键字</h2><p><code>new</code><strong>与</strong><code>delete</code><strong>配对使用</strong></p><p>使用<code>new</code>分配的内存必须显式地通过<code>delete</code>（对于单个对象）或<code>delete[]</code>（对于数组）来释放，以避免内存泄露：</p><p><strong>释放单个对象：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr; <span class="comment">// 释放 ptr 指向的对象</span></span><br></pre></td></tr></table></figure><p><strong>释放数组：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] arr; <span class="comment">// 释放 arr 指向的数组</span></span><br></pre></td></tr></table></figure><p><strong>示例代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Object created&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配单个对象</span></span><br><span class="line">    MyClass* myObject = <span class="keyword">new</span> <span class="built_in">MyClass</span>();</span><br><span class="line">    <span class="comment">// 分配对象数组</span></span><br><span class="line">    <span class="type">int</span>* myArray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 使用对象和数组...</span></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> myObject;</span><br><span class="line">    <span class="keyword">delete</span>[] myArray;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>new</code>被用来分配一个<code>MyClass</code>类型的对象和一个整数数组，然后使用<code>delete</code>和<code>delete[]</code>来释放内存。每个<code>new</code>都对应一个<code>delete</code>，保证了动态分配的内存被适当管理。</p><h1 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h1><p><strong>静态成员变量</strong></p><ul><li><p><strong>定义</strong>：静态成员变量是类的所有对象共享的变量。与普通成员变量相比，无论创建了多少个类的实例，静态成员变量<strong>只有一份拷贝</strong>。</p></li><li><p><strong>初始化</strong>：静态成员变量需要在类外进行初始化，通常在类的实现文件中。</p></li><li><p><strong>访问</strong>：静态成员变量可以通过类名直接访问，不需要创建类的对象。也可以通过类的对象访问。</p></li><li><p><strong>用途</strong>：常用于存储类级别的信息（例如，计数类的实例数量）或全局数据需要被类的所有实例共享。</p></li></ul><p><strong>静态成员函数</strong></p><ul><li><p><strong>定义</strong>：静态成员函数是可以<strong>不依赖于类的实例而被调用的函数</strong>。它不能访问类的非静态成员变量和非静态成员函数。</p></li><li><p><strong>访问</strong>：类似于静态成员变量，静态成员函数可以通过<strong>类名直接调用</strong>，也可以通过<strong>类的实例</strong>调用。</p></li><li><p><strong>用途</strong>：常用于实现与具体对象无关的功能，或访问静态成员变量。</p></li></ul><p>使用示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span>* Data;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> NumOfClass;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">my_class</span>()&#123;</span><br><span class="line">            Data = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">            NumOfClass++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*该函数为析构函数*/</span></span><br><span class="line">        ~<span class="built_in">my_class</span>()&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function has been used&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span>[] Data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Cout_Class</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            NumOfClass++;</span><br><span class="line">            cout &lt;&lt; NumOfClass &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*静态变量一定要在类的外面初始化*/</span></span><br><span class="line"><span class="type">int</span> my_class::NumOfClass = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    my_class p1[<span class="number">6</span>];</span><br><span class="line">    my_class::<span class="built_in">Cout_Class</span>();</span><br><span class="line">    my_class::<span class="built_in">Cout_Class</span>();</span><br><span class="line">    my_class::<span class="built_in">Cout_Class</span>();</span><br><span class="line">    my_class::<span class="built_in">Cout_Class</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意静态变量要在类外面初始化。</strong>静态成员变量在C++中的一个典型应用是用于跟踪类的实例数量。这个案例体现了静态成员变量的特性，它们在类的所有实例之间共享，因此适合于存储所有实例共有的信息。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>本地部署AI知识库</title>
      <link href="/2024/12/15/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2AI%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
      <url>/2024/12/15/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2AI%E7%9F%A5%E8%AF%86%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>突发奇想，打算在本机部署chat大语言模型，同时部署embedding模型将文档等数据转化成向量，实现知识库。</p><h1 id="Ollama本地部署模型"><a href="#Ollama本地部署模型" class="headerlink" title="Ollama本地部署模型"></a>Ollama本地部署模型</h1><p><a href="(https://ollama.com/)">Ollama</a> 是一个用于本地部署和运行大型语言模型（LLM）的平台，旨在让开发者和研究人员能够在本地计算机上高效、低延迟地运行和使用人工智能模型。它支持多种预训练的语言模型，并提供了一个简单易用的界面和 API，帮助用户在无需云端依赖的情况下进行自然语言处理、对话生成、文本分析等任务。</p><h2 id="Ollama相关指令"><a href="#Ollama相关指令" class="headerlink" title="Ollama相关指令"></a>Ollama相关指令</h2><p>Ollama 提供了一些常用的命令行操作指令来帮助用户管理模型、启动服务、加载模型等。以下是一些常见的 Ollama 操作指令：</p><h3 id="1-ollama-pull"><a href="#1-ollama-pull" class="headerlink" title="1. ollama pull &lt;model-name&gt;"></a>1. <strong><code>ollama pull &lt;model-name&gt;</code></strong></h3><ul><li><strong>作用</strong>：下载并安装指定的模型。</li><li><strong>示例</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama pull llama-7b</span><br></pre></td></tr></table></figure>该命令会下载名为 <code>llama-7b</code> 的模型到本地。</li></ul><h3 id="2-ollama-list"><a href="#2-ollama-list" class="headerlink" title="2. ollama list"></a>2. <strong><code>ollama list</code></strong></h3><ul><li><strong>作用</strong>：列出当前本地已安装的所有模型。</li><li><strong>示例</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama list</span><br></pre></td></tr></table></figure>该命令会列出你已经下载并安装在本地的模型列表。</li></ul><h3 id="3-ollama-run"><a href="#3-ollama-run" class="headerlink" title="3. ollama run &lt;model-name&gt;"></a>3. <strong><code>ollama run &lt;model-name&gt;</code></strong></h3><ul><li><strong>作用</strong>：直接运行并与指定模型进行交互。</li><li><strong>示例</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run llama-7b</span><br></pre></td></tr></table></figure>该命令会启动一个交互式会话，并与指定的模型进行对话。</li></ul><h3 id="4-ollama-rm"><a href="#4-ollama-rm" class="headerlink" title="4. ollama rm &lt;model-name&gt;"></a>4. <strong><code>ollama rm &lt;model-name&gt;</code></strong></h3><ul><li><strong>作用</strong>：删除指定的本地模型。</li><li><strong>示例</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama <span class="built_in">rm</span> llama-7b</span><br></pre></td></tr></table></figure>该命令会删除名为 <code>llama-7b</code> 的模型，释放本地存储空间。</li></ul><h3 id="5-ollama-serve"><a href="#5-ollama-serve" class="headerlink" title="5. ollama serve"></a>5. <strong><code>ollama serve</code></strong></h3><ul><li><strong>作用</strong>：启动 Ollama 的本地服务，通常用于为外部应用提供 API 接口。</li><li><strong>示例</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama serve</span><br></pre></td></tr></table></figure>启动服务后，Ollama 会在本地启动一个服务器，默认端口可能为 <code>5000</code> 或 <code>11434</code>，你可以通过访问 <code>http://localhost:&lt;port&gt;</code> 与模型进行交互。</li></ul><h3 id="6-ollama-show"><a href="#6-ollama-show" class="headerlink" title="6. ollama show &lt;model-name&gt;"></a>6. <strong><code>ollama show &lt;model-name&gt;</code></strong></h3><ul><li><strong>作用</strong>：查看已安装模型的详细信息，包括模型的版本、参数等。</li><li><strong>示例</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama show llama-7b</span><br></pre></td></tr></table></figure>该命令会显示 <code>llama-7b</code> 模型的详细信息。</li></ul><h3 id="其他命令选项"><a href="#其他命令选项" class="headerlink" title="其他命令选项"></a>其他命令选项</h3><ul><li>**<code>ollama help</code>**：查看所有可用的 Ollama 命令。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama <span class="built_in">help</span></span><br></pre></td></tr></table></figure>该命令会列出所有可用的命令和参数，并显示简要的使用说明。</li></ul><h2 id="Ollama模型推荐"><a href="#Ollama模型推荐" class="headerlink" title="Ollama模型推荐"></a>Ollama模型推荐</h2><p>个人电脑如果配备较好的个人显卡可以尝试<code>7b~32b</code>的模型，<code>70b</code>的模型虽然较为智能<strong>But</strong>速度会非常慢，且需要至少32GB 的显存，不是非常推荐。笔记本用户如果想尝试可以使用<code>llama3.2</code>，其主攻轻量化的场景有<code>1b</code>和<code>3b</code>两个版本可供选择。如果有40系显卡的加持可以尝试<code>7b</code>以上<code>70b</code>以下的模型。</p><p><strong>本人安装模型如下</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME                              ID              SIZE      MODIFIED</span><br><span class="line">qwen2.5:14b                       7cdf5a0187d5    9.0 GB    6 minutes ago</span><br><span class="line">qwen2.5:32b                       9f13ba1299af    19 GB     21 minutes ago</span><br><span class="line">nomic-embed-text:latest           0a109f422b47    274 MB    55 minutes ago</span><br><span class="line">llama3.1:8b                       46e0c10c039e    4.9 GB    55 minutes ago</span><br><span class="line">shaw/dmeta-embedding-zh:latest    55960d8a3a42    408 MB    18 hours ago</span><br></pre></td></tr></table></figure><p>其中<code>nomic-embed-text:latest</code>和<code>shaw/dmeta-embedding-zh:latest</code>为Embedding嵌入模型，其余为Chat模型。<br><strong>Embedding（嵌入）模型</strong>是自然语言处理（NLP）和机器学习中的一个重要概念，它将高维的离散数据（如单词、句子、图片等）转换为低维的、连续的向量表示。通过这种方式，嵌入模型能够将复杂的输入数据转化为机器学习算法可以处理的数值格式，同时保持数据的语义关系和结构。</p><h3 id="Embedding模型的作用"><a href="#Embedding模型的作用" class="headerlink" title="Embedding模型的作用"></a>Embedding模型的作用</h3><ul><li><p><strong>将离散数据转换为连续向量</strong>：许多机器学习模型（如神经网络）不能直接处理离散的非数值数据（如文本、类别标签等）。Embedding 模型通过将这些离散的对象（例如单词、句子或图像）映射到一个连续的向量空间，使它们变得适合于计算机处理。</p></li><li><p><strong>保留语义和上下文信息</strong>：嵌入模型的一个重要特点是能够将语义相似的对象映射到相似的向量位置。举例来说，<strong>Word2Vec</strong> 和 <strong>GloVe</strong> 这样的词嵌入模型会使得“猫”和“狗”在向量空间中的位置靠得很近，因为它们在许多上下文中具有相似的意义。这种特性对于许多下游任务（如语义分析、情感分析等）非常有用。</p></li><li><p><strong>降低维度</strong>：通过将数据从高维空间映射到低维空间，Embedding 模型不仅能减少计算量，还能减少噪声和冗余信息。这对于提高模型的性能和训练效率至关重要，尤其是在处理大规模数据时。</p></li><li><p><strong>提升模型泛化能力</strong>：通过使用嵌入向量，模型可以捕获到更丰富的特征表示，从而提高其泛化能力。例如，通过词嵌入，模型能够理解“跑步”和“运动”之间的关系，而不仅仅是将它们视为完全不同的单词。</p></li></ul><h3 id="Embedding模型的常见类型"><a href="#Embedding模型的常见类型" class="headerlink" title="Embedding模型的常见类型"></a>Embedding模型的常见类型</h3><ul><li><p><strong>Word Embeddings（词嵌入）</strong>：</p><ul><li><strong>Word2Vec</strong>：基于上下文的词嵌入模型，分为两种架构——CBOW（Continuous Bag of Words）和 Skip-gram。</li><li><strong>GloVe</strong>：通过矩阵分解技术生成的词嵌入模型，注重捕捉全局统计信息。</li><li><strong>FastText</strong>：在 Word2Vec 的基础上进一步考虑了词内的子词信息，能够更好地处理未知词汇。</li></ul></li><li><p><strong>Sentence Embeddings（句子嵌入）</strong>：</p><ul><li><strong>Doc2Vec</strong>：是 Word2Vec 的扩展，能够为整个文档（句子、段落等）生成一个固定的向量表示。</li><li>**Universal Sentence Encoder (USE)**：一种用于生成句子嵌入的模型，能够生成固定长度的句子向量表示，适用于各种句子级别的任务。</li></ul></li><li><p><strong>Contextual Embeddings（上下文嵌入）</strong>：</p><ul><li><strong>BERT</strong>：通过 Transformer 架构生成上下文相关的嵌入表示，可以为每个单词生成不同的嵌入向量，依赖于单词的上下文。</li><li><strong>GPT</strong>：基于自回归模型生成的嵌入，能够生成连贯的文本和语境感知的嵌入表示。</li></ul></li><li><p><strong>Multimodal Embeddings（多模态嵌入）</strong>：</p><ul><li><strong>CLIP</strong>：结合图像和文本信息的多模态嵌入模型，通过学习图像和文本之间的关联，能够进行跨模态检索和图像-文本匹配。</li></ul></li></ul><p><strong>总而言之，言而总之。Embedding模型可以将用户提供的数据识别制作成库，为Chat模型提供知识基础，安装Embedding模型是构建个人知识库的必要一步。</strong></p><h1 id="基于RAGflow搭建本地知识库"><a href="#基于RAGflow搭建本地知识库" class="headerlink" title="基于RAGflow搭建本地知识库"></a>基于RAGflow搭建本地知识库</h1><p>RAGflow 是一个基于 LLM 的开源知识库构建工具，它提供了一系列的组件，包括数据源、数据处理、模型、评估等，使得用户可以轻松地搭建知识库。开源地址：<a href="https://github.com/infiniflow/ragflow">https://github.com/infiniflow/ragflow</a></p><h2 id="RAGflow搭建步骤"><a href="#RAGflow搭建步骤" class="headerlink" title="RAGflow搭建步骤"></a>RAGflow搭建步骤</h2><p>由于开源仓库中有详细的使用教程，这里简单描述，突出易错关键步骤。</p><h3 id="1-安装Docker"><a href="#1-安装Docker" class="headerlink" title="1.安装Docker"></a>1.安装Docker</h3><p>可以阅读文章<a href="https://blog.csdn.net/Liuj666/article/details/126099982?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522070e248a9f83b077fe95f17e62b30502%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=070e248a9f83b077fe95f17e62b30502&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-126099982-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=Windows%E5%AE%89%E8%A3%85docker&spm=1018.2226.3001.4187">Windows 安装docker（详细图解）</a></p><h3 id="2-git拉取仓库"><a href="#2-git拉取仓库" class="headerlink" title="2.git拉取仓库"></a>2.git拉取仓库</h3><p>通过<code>git clone</code>命令拉取仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/infiniflow/ragflow.git</span><br></pre></td></tr></table></figure><h3 id="3-拉取Docker文件"><a href="#3-拉取Docker文件" class="headerlink" title="3.拉取Docker文件"></a>3.拉取Docker文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ragflow</span><br><span class="line">$ docker compose -f docker/docker-compose.yml up -d</span><br></pre></td></tr></table></figure><p>注意执行该命令时要启动Docker,有条件使用科学上网,最好以管理员权限运行<code>CMD</code>。<br>Docker服务运行成功如图：<br><img src="https://s2.loli.net/2024/12/15/eFGHQdBp7siyRZv.png" width="80%"></p><h3 id="4-添加本地大模型"><a href="#4-添加本地大模型" class="headerlink" title="4.添加本地大模型"></a>4.添加本地大模型</h3><p>我的Ollama和RAGflow都是部署在同一台机器上的，但是RAGflow在Docker中，所以基础URL填写如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://host.docker.internal:11434</span><br></pre></td></tr></table></figure><p>RAGflow中Ollama添加模型如图：<br><img src="https://s2.loli.net/2024/12/15/xnN5JeiCoyhT4Gl.png" width="80%"></p><p>至此搭建工作完成，可以访问<code>http://localhost/knowledge</code>，使用RAGflow提供的服务进行知识库问答。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP32学习笔记</title>
      <link href="/2024/11/24/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/11/24/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="ESP32开发相关链接"><a href="#ESP32开发相关链接" class="headerlink" title="ESP32开发相关链接"></a>ESP32开发相关链接</h1><p>开发ESP32可以采用IDF和Arduino IDE进行开发。为了进一步学习LVGL图形库和FreeRTOS，我选择使用乐鑫IDF进行开发。IDT开发官方文档可见<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.3/esp32/get-started/index.html#id2">快速入门</a></p><h1 id="一些idf常用命令"><a href="#一些idf常用命令" class="headerlink" title="一些idf常用命令"></a>一些idf常用命令</h1><p>idf工具主要调用<code>idf.py</code>这个python脚本，通过传递不同的参数实现不同功能，如交叉编译等。为了终端可以调用该指令需要将其添加路径到系统环境变量中,Linux系统下在目录下运行shell脚本<code>$ ./source export.sh</code>即可自动添加系统环境变量。</p><h2 id="创建一个空工程"><a href="#创建一个空工程" class="headerlink" title="创建一个空工程"></a>创建一个空工程</h2><p>其中my_project为自定义工程名，该命令会创建一个空工程，并生成工程文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py create-project my_project</span><br></pre></td></tr></table></figure><h2 id="设置芯片类型"><a href="#设置芯片类型" class="headerlink" title="设置芯片类型"></a>设置芯片类型</h2><ul><li>ESP32系列模组：idf.py set-target esp32</li><li>ESP32-S2系列模组：idf.py set-target esp32s2</li><li>ESP32-C3系列模组：idf.py set-target esp32c3</li><li>ESP32-S3系列模组：idf.py set-target esp32s3</li></ul><p>这里我们以ESP32-S3系列模组为例，在终端内运行命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py set-target ESP32s3</span><br></pre></td></tr></table></figure><p>idf自动切换为S3型号。</p><h2 id="构建-清除工程"><a href="#构建-清除工程" class="headerlink" title="构建&amp;清除工程"></a>构建&amp;清除工程</h2><p>构建指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py build</span><br></pre></td></tr></table></figure><p>由于芯片具有一定复杂度，编译中产生大量中间文件，编译后工程内存占用高达百兆不利于传递存储。清除编译中间文件指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py clean</span><br></pre></td></tr></table></figure><h2 id="下载-调试工程"><a href="#下载-调试工程" class="headerlink" title="下载&amp;调试工程"></a>下载&amp;调试工程</h2><p>下载指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py flash</span><br></pre></td></tr></table></figure><p>可以使用下面指令监视串口输出，PORT为串口设备，如&#x2F;dev&#x2F;ttyUSB0。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py -p PORT monitor</span><br></pre></td></tr></table></figure><p>也可以直接调试工程，使用下面指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py monitor</span><br></pre></td></tr></table></figure><p><span style="color: red;">特别注意Linux终端退出需要按<kbd>Ctrl</kbd>+<kbd>[</kbd>, 其他什么都不好使。</span></p><h1 id="FreeRTOS基础"><a href="#FreeRTOS基础" class="headerlink" title="FreeRTOS基础"></a>FreeRTOS基础</h1><p>由于ESP32的芯片具有多核特性(如ESP32s3为基于Tensilica Xtensa LX6架构双核芯片)，主核和协处理器分别采用240MHz和160MHz的频率。为了更好的分配任务，所以IDF使用FreeRTOS操作系统进行多线程编程。<br><strong>一个任务可以为以下几种状态</strong>:</p><ul><li><strong>运行(Running)</strong> ：如果处理器为单核，同一时刻只有一个任务被执行。</li><li><strong>准备状态</strong> ：任务处于能够执行但是没有执行的状态，原因为操作系统在执行一些高优先级的任务。</li><li><strong>阻塞(Blocked)</strong> ：任务正在等待时间或者外部事件，如调用<code>vTaskDelay()</code>延时。任务也可以通过阻塞来等待队列、信号量、事件组、通知或信号量事件。处于阻塞状态的任务通常有一个”超时”期， 超时后任务将被超时，并被解除阻塞。</li><li><strong>挂起(Suspended)</strong> ：与“阻塞”状态下的任务一样， “挂起”状态下的任务不能 被选择进入运行状态，但处于挂起状态的任务没有超时。相反，任务只有在分别通过 <code>vTaskSuspend()</code> 和 <code>xTaskResume()</code>API 调用明确命令时 才会进入或退出挂起状态。</li></ul><p><strong>任务优先级</strong>：每个任务均被分配了从 0 到 ( <code>configMAX_PRIORITIES - 1</code> ) 的优先级，其中的<code>configMAX_PRIORITIES</code> 在 <code>FreeRTOSConfig.h</code> 中定义，<span style="color: red;">低优先级数字表示低优先级任务,数字越大任务优先级越高,空闲任务的优先级为零。</span></p><h2 id="FreeRTOS创建任务"><a href="#FreeRTOS创建任务" class="headerlink" title="FreeRTOS创建任务"></a>FreeRTOS创建任务</h2><p>如下是创建一个乐鑫官方移植的任务创建函数<code>xTaskCreatePinnedToCor</code>(<span style="color: red;">推荐使用</span>)它有7个参数，参数为任务函数指针、任务名称、堆栈大小、任务参数、优先级、任务句柄、内核号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreatePinnedToCore</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pvTaskCode, <span class="comment">//任务函数指针，原型是 void fun(void *param)</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *constpcName, <span class="comment">//任务的名称，打印调试可能会有用</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> usStackDepth,<span class="comment">//指定的任务堆栈空间大小（字节）</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> *constpvParameters, <span class="comment">//任务参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority, <span class="comment">// 优先级，数字越大，优先级越大0到(configMAX_PRIORITIES - 1)</span></span></span><br><span class="line"><span class="params">    TaskHandle_t *constpvCreatedTask, <span class="comment">//传回来的任务句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> BaseType_t xCoreID)</span> <span class="comment">//分配在哪个内核上运行</span></span><br></pre></td></tr></table></figure><p>如果任务创建成功则返回pdPASS，否则返回pdFAIL。<br>创建函数还可以是<code>xTaskCreate</code>(内部还是使用了<code>xTaskCreatePinnedToCore</code>但是会自动分配内核)函数及参数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,<span class="comment">//指向任务函数的指针。</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,<span class="comment">//任务的名称（用于调试）。</span></span></span><br><span class="line"><span class="params">    configSTACK_DEPTH_TYPE usStackDepth,<span class="comment">//任务堆栈的深度（以堆栈项为单位）。</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * pvParameters,<span class="comment">//传递给任务函数的参数。</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,<span class="comment">//任务的优先级</span></span></span><br><span class="line"><span class="params">    TaskHandle_t * pxCreatedTask<span class="comment">//用于存储创建的任务句柄的指针（可以为 NULL）。</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h3 id="直接创建任务和静态任务的区别"><a href="#直接创建任务和静态任务的区别" class="headerlink" title="直接创建任务和静态任务的区别"></a>直接创建任务和静态任务的区别</h3><p>在FreeRTOS中，直接创建任务（通常指的是使用<code>xTaskCreate</code>函数动态创建任务）和创建静态任务（使用<code>xTaskCreateStatic</code>函数）之间存在几个关键区别。以下是对这两者的详细比较：<br><strong>1. 内存分配方式</strong></p><ul><li><strong>直接创建任务（动态创建）</strong>：内存是在运行时通过动态内存分配函数（如<code>pvPortMalloc</code>）来分配的。创建任务时，不需要预先定义和初始化额外的变量来存储任务信息。任务的相关信息直接存储在动态分配的内存中。动态创建任务的内存空间可以在任务完成后释放，因此可以在运行时动态地创建和删除任务。</li><li><strong>创建静态任务</strong>：内存是在编译时分配的，需要定义并初始化一个<code>StaticTask_t</code>类型的变量来存储任务的相关信息。静态创建任务的内存空间在任务整个运行期间都被任务所占用，直到任务被删除。静态创建任务通常在应用程序的启动阶段进行，<span style="color: red;">任务的数量是固定的，无法在运行时动态调整。</span><br><strong>2. 内存管理</strong></li><li><strong>直接创建任务</strong>：由于内存是动态分配的，因此需要在任务完成后手动释放内存（尽管FreeRTOS本身可能并不直接提供释放任务内存的API，但可以通过删除任务来间接释放内存）。动态内存分配可能增加内存碎片化的风险。</li><li><strong>创建静态任务</strong>：内存是静态分配的，因此不需要担心内存碎片化和手动释放内存的问题。但由于内存是在编译时分配的，因此需要预先知道任务所需的内存大小。<br><strong>3. 灵活性</strong></li><li><strong>直接创建任务</strong>：提供了更高的灵活性，因为可以在运行时根据需要动态地创建和删除任务。适用于任务数量可能会根据系统状态或用户交互而动态变化的应用场景。</li><li><strong>创建静态任务</strong>：灵活性较低，因为任务的数量和内存大小在编译时就已确定。但由于内存是静态分配的，因此可以提供更稳定的内存使用模式，并减少运行时内存分配的开销。<br><strong>1. 使用场景</strong></li><li><strong>直接创建任务</strong>： 适用于需要动态调整任务数量和类型的系统，如事件驱动系统、多协议通信系统或并行处理系统。</li><li><strong>创建静态任务</strong>：适用于任务数量和类型在编译时就已确定的系统，或对内存使用有严格要求的应用场景。</li></ul><h3 id="创建静态任务的函数"><a href="#创建静态任务的函数" class="headerlink" title="创建静态任务的函数"></a>创建静态任务的函数</h3><p>乐鑫官方移植的FreeRTOS提供了创建静态任务的函数<code>xTaskCreateStaticPinnedToCore</code>，它需要用户提前分配好任务栈和任务控制块的内存，然后调用该函数创建静态任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreateStaticPinnedToCore</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,      <span class="comment">// 指向任务函数的指针，任务函数是任务执行的具体逻辑</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,      <span class="comment">// 任务的名称，用于调试和识别任务</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth,    <span class="comment">// 任务堆栈的大小，以字为单位（通常是4字节）</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * pvParameters,            <span class="comment">// 传递给任务函数的参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,         <span class="comment">// 任务的优先级，优先级较高的任务会优先执行</span></span></span><br><span class="line"><span class="params">    StackType_t * pxStackBuffer,    <span class="comment">// 指向任务堆栈缓冲区的指针，缓冲区必须由调用者分配</span></span></span><br><span class="line"><span class="params">    StaticTask_t * pxStaticTaskBuffer, <span class="comment">// 指向静态任务控制块（TCB）的指针，结构体用于存储任务的相关信息，必须由调用者分配</span></span></span><br><span class="line"><span class="params">    BaseType_t xCoreID              <span class="comment">// 指定任务运行的 CPU 核心 ID，0 或 1</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>FreeRTOS的创建函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreateStatic</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,      <span class="comment">// 指向任务函数的指针，任务函数是任务执行的具体逻辑</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,      <span class="comment">// 任务的名称，用于调试和识别任务</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth,    <span class="comment">// 任务堆栈的大小，以字为单位（通常是4字节）</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * pvParameters,            <span class="comment">// 传递给任务函数的参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,         <span class="comment">// 任务的优先级，优先级较高的任务会优先执行</span></span></span><br><span class="line"><span class="params">    StackType_t * pxStackBuffer,    <span class="comment">// 指向任务堆栈缓冲区的指针，缓冲区必须由调用者分配</span></span></span><br><span class="line"><span class="params">    StaticTask_t * pxStaticTaskBuffer <span class="comment">// 指向静态任务控制块（TCB）的指针，结构体用于存储任务的相关信息，必须由调用者分配</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h3 id="FreeRTOS任务创建案例"><a href="#FreeRTOS任务创建案例" class="headerlink" title="FreeRTOS任务创建案例"></a>FreeRTOS任务创建案例</h3><p>如下创建两个任务并打印相关的数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span><span class="comment">//只要使用FreeRTOS就需要包含该文件，</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span><span class="comment">//创建任务有关的函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span><span class="comment">//用于调试的功能，通过串口打印数据</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*任务A函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskA</span><span class="params">(<span class="type">void</span>* param)</span> <span class="comment">//void*是一种特殊的指针类型，被称为“无类型指针”或“通用指针”。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">100</span>) i++;</span><br><span class="line">        <span class="keyword">else</span> i = <span class="number">0</span>;</span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TaskA&quot;</span>,<span class="string">&quot;Timer_%d&quot;</span>,i);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">500</span>));<span class="comment">//pdMS_TO_TICKS(500)将系统节拍转换成具体时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*任务B函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskB</span><span class="params">(<span class="type">void</span>* param)</span> <span class="comment">//void*是一种特殊的指针类型，被称为“无类型指针”或“通用指针”。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">100</span>) i++;</span><br><span class="line">        <span class="keyword">else</span> i = <span class="number">0</span>;</span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TaskB&quot;</span>,<span class="string">&quot;Timer_%d&quot;</span>,i);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">2000</span>));<span class="comment">//pdMS_TO_TICKS(500)将系统节拍转换成具体时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    xTaskCreatePinnedToCore(TaskA, <span class="string">&quot;TaskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">1</span>);<span class="comment">//栈空间最小2048</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskB, <span class="string">&quot;TaskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">1</span>);<span class="comment">//栈空间最小2048</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FreeRTOS任务阻塞延时"><a href="#FreeRTOS任务阻塞延时" class="headerlink" title="FreeRTOS任务阻塞延时"></a>FreeRTOS任务阻塞延时</h2><p>FreeRTOS提供了两种阻塞延时函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延时 xTicksToDelay 个周期</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">( <span class="type">const</span> TickType_t xTicksToDelay )</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelayUntil</span><span class="params">( <span class="type">const</span> TickType_t *pxPreviousWakeTime, <span class="type">const</span> TickType_t xTimeIncrement )</span>;</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：<code>const TickType_t *pxPreviousWakeTime</code>: 指向上次任务唤醒时间的指针。这个变量应该在第一次调用 vTaskDelayUntil 之前初始化为当前时间。<code>const TickType_t xTimeIncrement</code>: 任务每次执行之间的时间间隔，以滴答数（<code>ticks</code>）为单位。<br><strong>使用步骤</strong>：初始化 <code>pxPreviousWakeTime</code>: 在任务第一次执行时，需要初始化 <code>pxPreviousWakeTime</code> 为当前时间。调用 <code>vTaskDelayUntil</code>: 在每次任务执行结束时，调用<code>vTaskDelayUntil</code>函数，传入<code>pxPreviousWakeTime</code>和<code>xTimeIncrement</code>。<br>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPeriodicTask</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    TickType_t xLastWakeTime;</span><br><span class="line">    <span class="type">const</span> TickType_t xFrequency = <span class="number">1000</span> / portTICK_PERIOD_MS; <span class="comment">// 1000 ms (1 second)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 xLastWakeTime 为当前时间</span></span><br><span class="line">    xLastWakeTime = xTaskGetTickCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 任务执行的逻辑</span></span><br><span class="line">        <span class="comment">// 例如：打印一条消息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Task is running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延迟直到下次唤醒时间</span></span><br><span class="line">        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FreeRTOS任务同步"><a href="#FreeRTOS任务同步" class="headerlink" title="FreeRTOS任务同步"></a>FreeRTOS任务同步</h2><p><strong>RTOS中的同步</strong> ：是指是不同任务之间或者任务与外部事件之间的协同工作方式,确保多个并发执行的任务按照预期的顺序或时机执行。它涉及到线程或任务间的通信和协调机制，目的是为了<span style="color: red;">避免数据竞争、解决竞态条件</span>,并确保系统的正确行为。<br><strong>互斥</strong> ：某一资源同时只允许一个线程或任务访问，其他线程或任务必须等待。<span style="color: red;">具有唯一性和排他性</span>。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是任务间通信的主要形式。 它们可以用于在任务之间以及中断和任务之间发送消息。 在大多数情况下，它们作为线程安全的 FIFO（先进先出）缓冲区使用，新数据被发送到队列的后面， 尽管数据也可以发送到前面。<span style="color: red;">尾部进入，头部读出</span><br><code>QueueHandle_t</code>为队列的句柄类型，本质上是一个指针。常用API函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t <span class="title function_">xQueueCreate</span><span class="params">( <span class="comment">//创建一个队列，成功返回队列句柄</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxQueueLength, <span class="comment">//队列容量</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxItemSize <span class="comment">//每个队列项所占内存的大小（单位是字节）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSend</span><span class="params">( <span class="comment">//向队列头部发送一个消息</span></span></span><br><span class="line"><span class="params">    QueueHandle_t xQueue, <span class="comment">// 队列句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> * pvItemToQueue, <span class="comment">//要发送的消息指针</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSendToBack</span><span class="params">( <span class="comment">//向队列尾部发送一个消息</span></span></span><br><span class="line"><span class="params">    QueueHandle_t xQueue, <span class="comment">// 队列句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> * pvItemToQueue, <span class="comment">//要发送的消息指针</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueReceive</span><span class="params">( <span class="comment">//从队列接收一条消息</span></span></span><br><span class="line"><span class="params">    QueueHandle_t xQueue, <span class="comment">//队列句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * pvBuffer, <span class="comment">//指向接收消息缓冲区的指针。</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSendFromISR</span><span class="params">( <span class="comment">//xQueueSend 的中断版本</span></span></span><br><span class="line"><span class="params">    QueueHandle_t xQueue, <span class="comment">// 队列句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> * pvItemToQueue, <span class="comment">//要发送的消息指针</span></span></span><br><span class="line"><span class="params">    BaseType_t *pxHigherPriorityTaskWoken )</span>; <span class="comment">//指出是否有高优先级的任务被唤醒</span></span><br></pre></td></tr></table></figure><p><strong>队列使用案例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">QueueHandle_t my_queue = <span class="literal">NULL</span>;<span class="comment">//创建队列指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> <span class="comment">//定义一个数据类型</span></span><br><span class="line">    <span class="type">int</span> vslue;</span><br><span class="line">    <span class="type">int</span> Num;</span><br><span class="line">&#125;QueueData;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskA</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//创建任务A，向队列中发送数据</span></span><br><span class="line">&#123;</span><br><span class="line">    QueueData Temp;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;Temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(QueueData));<span class="comment">//初始化结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Temp.Num++;</span><br><span class="line">        Temp.vslue+=<span class="number">2</span>;</span><br><span class="line">        xQueueSend(my_queue, &amp;Temp, <span class="number">100</span>);<span class="comment">//向队列中发送数据</span></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskB</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//创建任务B，从队列中接收数据</span></span><br><span class="line">&#123;</span><br><span class="line">    QueueData Temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pdTRUE == xQueueReceive(my_queue, &amp;Temp, <span class="number">100</span>))<span class="comment">//从队列中接收数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(<span class="string">&quot;TaskB_Receive&quot;</span>, <span class="string">&quot;Value = %d, Num = %d。&quot;</span>,Temp.vslue, Temp.Num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    my_queue = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(QueueData));<span class="comment">//初始化队列</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskA, <span class="string">&quot;TaskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">1</span>);<span class="comment">//创建任务</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskB, <span class="string">&quot;TaskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">3</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是用来保护共享资源不会被多个任务并发使用。信号量使用起来比较简单。因为在 freeRTOS 中它本质上就是队列，只不过<span style="color: red;">信号量只关心队列中的数量而不关心队列中的消息内容</span>，在 freeRTOS 中有两种常用的信号量，一是计数信号量，而是二进制信号量。</p><ul><li>二进制信号量很简单，就是信号量总数只有 1，也就是这个图中总雨伞数量只有 1。</li><li>计数信号量则可以自定义总共的信号量</li></ul><p>信号量的句柄<code>SemaphoreHandle_t</code>,常用API函数如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建二值信号量，成功则返回信号量句柄（二值信号量最大只有 1 个）</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinary</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建计数信号量，成功则返回信号量句柄</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">(</span></span><br><span class="line"><span class="params">    UBaseType_t uxMaxCount, <span class="comment">//最大信号量数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxInitialCount)</span>; <span class="comment">//初始信号量数</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个信号量，如果获得信号量，则返回 pdTRUE</span></span><br><span class="line">xSemaphoreTake( </span><br><span class="line">    SemaphoreHandle_t xSemaphore,<span class="comment">//信号量句柄</span></span><br><span class="line">    TickType_t xTicksToWait ); <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放一个信号量，及放回信号量，成功返回 pdTRUE</span></span><br><span class="line">xSemaphoreGive( SemaphoreHandle_t xSemaphore ); <span class="comment">//信号量句柄</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除信号量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/semphr.h&quot;</span><span class="comment">//信号量有关函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SemaphoreHandle_t My_sem;<span class="comment">//定义信号量的句柄</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskA</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//任务A负责发送信号量</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">        xSemaphoreGive(My_sem); <span class="comment">//信号量句柄</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskB</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//任务B接受到信号量之后打印标记</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pdTRUE == xSemaphoreTake(My_sem, <span class="number">100</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(<span class="string">&quot;TaskB&quot;</span>, <span class="string">&quot;sem is OK&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    My_sem = xSemaphoreCreateBinary();<span class="comment">//初始化句柄</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskA, <span class="string">&quot;TaskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(TaskB, <span class="string">&quot;TaskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁：与二进制信号量类似，但会发生优先级翻转。保证优先级一致性。<br>互斥锁的句柄<code>SemaphoreHandle_t</code>和信号量一样，常用API函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个互斥锁</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutex</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥量获取函数，成功则返回 pdTRUE</span></span><br><span class="line">xSemaphoreTake( </span><br><span class="line">    SemaphoreHandle_t xSemaphore,<span class="comment">//互斥锁句柄</span></span><br><span class="line">    TickType_t xTicksToWait ); <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure><p>获取函数的<code>TickType_t xTicksToWait</code>最好填写<code>portMAX_DELAY</code>无限延时，这样当任务A获取互斥锁后，任务B就无法获取锁了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥量释放函数 </span></span><br><span class="line">xSemaphoreGive( SemaphoreHandle_t xSemaphore ); <span class="comment">//互斥锁句柄</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除互斥锁</span></span><br><span class="line">vSemaphoreDelete( SemaphoreHandle_t xSemaphore );</span><br></pre></td></tr></table></figure><p><strong>示例代码如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/semphr.h&quot;</span><span class="comment">//互斥锁有关函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SemaphoreHandle_t My_Mutex;<span class="comment">//定义互斥锁的句柄</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskA</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//任务A负责发送信号量</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xSemaphoreTake(My_Mutex, portMAX_DELAY);<span class="comment">//获取互斥锁  //</span></span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TaskA&quot;</span>, <span class="string">&quot;Mutex is OK&quot;</span>);                    <span class="comment">//互斥锁保护区域</span></span><br><span class="line">        xSemaphoreGive(My_Mutex); <span class="comment">//释放互斥锁                //</span></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">2000</span>));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskB</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//任务B接受到信号量之后打印标记</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xSemaphoreTake(My_Mutex, portMAX_DELAY);<span class="comment">//获取互斥锁  //</span></span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TaskB&quot;</span>, <span class="string">&quot;Mutex is OK&quot;</span>);                    <span class="comment">//互斥锁保护区域</span></span><br><span class="line">        xSemaphoreGive(My_Mutex); <span class="comment">//释放互斥锁                //</span></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    My_Mutex = xSemaphoreCreateMutex();<span class="comment">//初始化互斥锁句柄</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskA, <span class="string">&quot;TaskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(TaskB, <span class="string">&quot;TaskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FreeRTOS事件组"><a href="#FreeRTOS事件组" class="headerlink" title="FreeRTOS事件组"></a>FreeRTOS事件组</h3><p><strong>事件位</strong>：用于指示事件是否发生，事件位通常称为事件标志。<br><strong>事件组</strong>：就是一组事件位，事件组中的事件位通过位编号来引用。<br>下图表示一个 24 位事件组， 使用 3 个位来保存前面描述的 3 个示例事件<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a5501132ff95ddc8f2d6aef123035ecb.png" alt="EventGroup"><br>接收事件时，可以根据感兴趣的参事件类型接收事件的单个或者多个事件类型。事件接收成功后，必须使用<code>xClearOnExit</code>选项来清除已接收到的事件类型，否则不会清除已接收 到的 事件 ，这样就需要用户显式清除事位。<br>函数句柄<code>EventGroupHandle_t</code>,相关API函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个事件组，返回事件组句柄，失败返回 NULL</span></span><br><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreate</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待事件组中某个标志位,用返回值以确定哪些位已完成设置</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupWaitBits</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">const</span> EventGroupHandle_t xEventGroup, <span class="comment">//事件组句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> EventBits_t uxBitsToWaitFor, <span class="comment">//哪些位需要等待</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> BaseType_t xClearOnExit, <span class="comment">//是否读取完成后自动清除标志位</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> BaseType_t xWaitForAllBits, <span class="comment">//是否等待的标志位都成功了才返回</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//最大阻塞时间</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置标志位</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupSetBits</span><span class="params">(</span></span><br><span class="line"><span class="params">    EventGroupHandle_t xEventGroup,<span class="comment">//事件组句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> EventBits_t uxBitsToSet )</span>; <span class="comment">//设置哪个位</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清除标志位</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupClearBits</span><span class="params">(</span></span><br><span class="line"><span class="params">    EventGroupHandle_t xEventGroup, <span class="comment">//事件组句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> EventBits_t uxBitsToClear )</span>; <span class="comment">//清除的标志位</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// xEventGroup: 事件组句柄，你要删除哪个事件组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vEventGroupDelete</span><span class="params">( EventGroupHandle_t xEventGroup )</span></span><br></pre></td></tr></table></figure><p><strong>示例代码如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/event_groups.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> EventGroupHandle_t s_testEvent;<span class="comment">//事件组句柄</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_taskA</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//事件任务A，用于定时标记事件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xEventGroupSetBits(s_testEvent,BIT0);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">        xEventGroupSetBits(s_testEvent,BIT1);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">event_taskB</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//事件任务B，等待事件组中BIT0和BIT1位</span></span><br><span class="line">&#123;</span><br><span class="line">    EventBits_t ev;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ev = xEventGroupWaitBits(s_testEvent,BIT0|BIT1,pdTRUE,pdFALSE,portMAX_DELAY);</span><br><span class="line">        <span class="keyword">if</span>(ev &amp; BIT0)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG,<span class="string">&quot;Event BIT0 set&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ev&amp; BIT1)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG,<span class="string">&quot;Event BIT1 set&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rtos_event_sample</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//事件例程初始化</span></span><br><span class="line">&#123;</span><br><span class="line">    s_testEvent = xEventGroupCreate();</span><br><span class="line">    xTaskCreatePinnedToCore(event_taskA,<span class="string">&quot;event_taskA&quot;</span>,<span class="number">2048</span>,<span class="literal">NULL</span>,<span class="number">3</span>,<span class="literal">NULL</span>,<span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(event_taskB,<span class="string">&quot;event_taskB&quot;</span>,<span class="number">2048</span>,<span class="literal">NULL</span>,<span class="number">3</span>,<span class="literal">NULL</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="直达任务通知"><a href="#直达任务通知" class="headerlink" title="直达任务通知"></a>直达任务通知</h3><p><strong>定义</strong>：每个 RTOS 任务都有一个任务通知数组。 每条任务通知 都有“挂起”或“非挂起”的通知状态， 以及一个 32 位通知值。直达任务通知是直接发送至任务的事件，而不是通过中间对象 （如队列、事件组或信号量）间接发送至任务的事件。向任务发送“直达任务通知” 会将目标任务通知设为“挂起”状态（此挂起不是挂起任务）。<br><strong>API常用函数如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于将事件直接发送到 RTOS 任务并可能取消该任务的阻塞状态</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotify</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskHandle_t xTaskToNotify, <span class="comment">//要通知的任务句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> ulValue, <span class="comment">//携带的通知值</span></span></span><br><span class="line"><span class="params">    eNotifyAction eAction )</span>; <span class="comment">//执行的操作</span></span><br></pre></td></tr></table></figure><p>需要注意的是参数 eAction 如下表所述:</p><table><thead><tr><th align="center">eAction 设置</th><th align="center">执行的操作</th></tr></thead><tbody><tr><td align="center">eNoAction</td><td align="center">目标任务接收事件，但其 通知值未更新。 在这种情况下，不使用 ulValue。</td></tr><tr><td align="center">eSetBits</td><td align="center">目标任务的通知值 使用 ulValue 按位或运算</td></tr><tr><td align="center">eIncrement</td><td align="center">目标任务的通知值自增 1（类似信号量的 give 操作）</td></tr><tr><td align="center">eSetValueWithOverwrite</td><td align="center">目标任务的通知值 无条件设置为 ulValue。</td></tr><tr><td align="center">eSetValueWithoutOrwrite</td><td align="center">如果目标任务没有 挂起的通知，则其通知值 将设置为 ulValue。如果目标任务已经有 挂起的通知，则不会更新其通知值。</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待接收任务通知</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyWait</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> ulBitsToClearOnEntry, <span class="comment">//进入函数清除的通知值位</span></span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> ulBitsToClearOnExit,<span class="comment">//退出函数清除的通知值位</span></span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> *pulNotificationValue, <span class="comment">//通知值</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//等待时长</span></span><br></pre></td></tr></table></figure><p><strong>示例代码如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/event_groups.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要使用任务通知，需要记录任务句柄</span></span><br><span class="line"><span class="type">static</span> TaskHandle_t s_notifyTaskAHandle;</span><br><span class="line"><span class="type">static</span> TaskHandle_t s_notifyTaskBHandle;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 任务通知A，用于定时向任务通知B直接传输数据</span></span><br><span class="line"><span class="comment"> * @param 无</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">notify_taskA</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> rec_val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (xTaskNotifyWait(<span class="number">0x00</span>, ULONG_MAX, &amp;rec_val, pdMS_TO_TICKS(<span class="number">1000</span>)) == pdTRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG,<span class="string">&quot;receive notify value:%lu&quot;</span>,rec_val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 任务通知B，实时接收任务通知A的数据</span></span><br><span class="line"><span class="comment"> * @param 无</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">notify_taskB</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> notify_val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xTaskNotify(s_notifyTaskAHandle, notify_val, eSetValueWithOverwrite);</span><br><span class="line">        notify_val++;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 任务通知例程初始化</span></span><br><span class="line"><span class="comment"> * @param 无</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtos_notify_sample</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    xTaskCreatePinnedToCore(notify_taskA,<span class="string">&quot;notify_taskA&quot;</span>,<span class="number">2048</span>,<span class="literal">NULL</span>,<span class="number">3</span>,&amp;s_notifyTaskAHandle,<span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(notify_taskB,<span class="string">&quot;notify_taskB&quot;</span>,<span class="number">2048</span>,<span class="literal">NULL</span>,<span class="number">3</span>,&amp;s_notifyTaskBHandle,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LVGL移植"><a href="#LVGL移植" class="headerlink" title="LVGL移植"></a>LVGL移植</h1><h2 id="拉取相关源码"><a href="#拉取相关源码" class="headerlink" title="拉取相关源码"></a>拉取相关源码</h2><p>在github网站上拉取相关的源码，在终端下执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> <span class="built_in">clone</span> --recursive https://github.com/lvgl/lvgl.git</span><br></pre></td></tr></table></figure><p>其中<code>--recursive</code>这是一个可选参数，它告诉Git在克隆主仓库的同时，也递归地克隆所有子模块。如果你的项目使用了Git子模块来引用其他项目，那么你需要使用这个参数来确保所有子模块也都被正确地克隆下来。<br>由于LVGL包含很多的版本，使用指令查看包含的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> tag</span><br></pre></td></tr></table></figure><p>按<code>q</code>退出查看，使用指令切换需要的版本v8.3.10：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> checkout v8.3.10</span><br></pre></td></tr></table></figure><h2 id="添加屏幕驱动"><a href="#添加屏幕驱动" class="headerlink" title="添加屏幕驱动"></a>添加屏幕驱动</h2><p>将驱动文件<code>st7789_driver.c</code>和<code>cst816t_driver.c</code>添加到components文件夹下，并添加<code>CMakeLists.txt</code>。内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">idf_component_register(</span><br><span class="line">    SRCS <span class="string">&quot;st7789_driver.c&quot;</span> <span class="string">&quot;cst816t_driver.c&quot;</span>   //添加相关文件</span><br><span class="line">    INCLUDE_DIRS    <span class="string">&quot;.&quot;</span>                         //添加相关路径为当前路径</span><br><span class="line">    REQUIRES    esp_lcd                         //导入依赖</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="链接lvgl接口"><a href="#链接lvgl接口" class="headerlink" title="链接lvgl接口"></a>链接lvgl接口</h2><p>链接lvgl接口步骤如下：</p><ol><li>初始化和注册LVGL显示驱动</li><li>初始化和注册LVGL触摸驱动</li><li>初始化ST7789硬件接口</li><li>初始化CST816T硬件接口</li><li>提供一个定时器给LVGL使用，作为心跳</li></ol><p>在main目录下添加文件<code>lv_port.c</code>和<code>lv_port.h</code>用于链接lvgl。内容如下：<br><strong>lv_port.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lvgl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;st7789_driver.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cst816t_driver.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driver/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.初始化和注册LVGL显示驱动</span></span><br><span class="line"><span class="comment">2.初始化和注册LVGL触摸驱动</span></span><br><span class="line"><span class="comment">3.初始化ST7789硬件接口</span></span><br><span class="line"><span class="comment">4.初始化CST816T硬件接口</span></span><br><span class="line"><span class="comment">5.提供一个定时器给LVGL使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAG     <span class="string">&quot;lv_port&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_WIDTH       240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_HEIGHT      280</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">lv_disp_drv_t</span>    disp_drv;<span class="comment">//显示驱动变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_flush_done_cb</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">    lv_disp_flush_ready(&amp;disp_drv);<span class="comment">//写入完成通知</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">disp_flush</span><span class="params">(<span class="keyword">struct</span> <span class="type">_lv_disp_drv_t</span> * disp_drv, <span class="type">const</span> <span class="type">lv_area_t</span> * area, <span class="type">lv_color_t</span> * color_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    st7789_flush(area-&gt;x1,area-&gt;x2 + <span class="number">1</span>,area-&gt;y1+<span class="number">20</span>,area-&gt;y2+<span class="number">20</span> + <span class="number">1</span>,color_p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_disp_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">lv_disp_draw_buf_t</span>   disp_buf;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> disp_buf_size = LCD_WIDTH*(LCD_HEIGHT/<span class="number">7</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不能使用C语言的malloc函数</span></span><br><span class="line">    <span class="type">lv_color_t</span> *disp1 = heap_caps_malloc(disp_buf_size*<span class="keyword">sizeof</span>(<span class="type">lv_color_t</span>),MALLOC_CAP_INTERNAL|MALLOC_CAP_DMA);<span class="comment">//MALLOC_CAP_INTERNAL表示从内部ram中申请   MALLOC_CAP_DMA表示需要使用DMA传输</span></span><br><span class="line">    <span class="type">lv_color_t</span> *disp2 = heap_caps_malloc(disp_buf_size*<span class="keyword">sizeof</span>(<span class="type">lv_color_t</span>),MALLOC_CAP_INTERNAL|MALLOC_CAP_DMA);</span><br><span class="line">    <span class="keyword">if</span>(!disp1 || !disp2)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG,<span class="string">&quot;disp buff malloc fail!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lv_disp_draw_buf_init(&amp;disp_buf,disp1,disp2,disp_buf_size);<span class="comment">//双缓存</span></span><br><span class="line"></span><br><span class="line">    lv_disp_drv_init(&amp;disp_drv);<span class="comment">//初始化显示成员</span></span><br><span class="line"></span><br><span class="line">    disp_drv.hor_res = LCD_WIDTH;</span><br><span class="line">    disp_drv.ver_res = LCD_HEIGHT;</span><br><span class="line">    disp_drv.draw_buf = &amp;disp_buf;</span><br><span class="line">    disp_drv.flush_cb = disp_flush;<span class="comment">//显示函数指针</span></span><br><span class="line">    lv_disp_drv_register(&amp;disp_drv);<span class="comment">//将显示驱动注册</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> IRAM_ATTR <span class="title function_">indev_read</span><span class="params">(<span class="keyword">struct</span> <span class="type">_lv_indev_drv_t</span> * indev_drv, <span class="type">lv_indev_data_t</span> * data)</span><span class="comment">//触摸接口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int16_t</span> x,y;</span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line">    cst816t_read(&amp;x,&amp;y,&amp;state);</span><br><span class="line">    data-&gt;point.x = x;</span><br><span class="line">    data-&gt;point.y = y;</span><br><span class="line">    data-&gt;state = state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_indev_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//注册输入驱动</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">lv_indev_drv_t</span> indev_drv;</span><br><span class="line">    lv_indev_drv_init(&amp;indev_drv);</span><br><span class="line">    indev_drv.type = LV_INDEV_TYPE_POINTER;<span class="comment">//输入方式--触摸</span></span><br><span class="line">    indev_drv.read_cb = indev_read;<span class="comment">//触摸函数指针</span></span><br><span class="line">    lv_indev_drv_register(&amp;indev_drv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">st7789_hw_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//初始化LCD硬件接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">st7789_cfg_t</span> st7789_config = &#123;</span><br><span class="line">        .cs = GPIO_NUM_39,</span><br><span class="line">        .bl = GPIO_NUM_45,</span><br><span class="line">        .dc = GPIO_NUM_38,</span><br><span class="line">        .clk = GPIO_NUM_18,</span><br><span class="line">        .mosi = GPIO_NUM_19,</span><br><span class="line">        .rst = GPIO_NUM_47,</span><br><span class="line">        .spi_fre = <span class="number">40</span>*<span class="number">1000</span>*<span class="number">1000</span>,</span><br><span class="line">        .height = LCD_HEIGHT,</span><br><span class="line">        .width = LCD_WIDTH,</span><br><span class="line">        .spin = <span class="number">0</span>,</span><br><span class="line">        .done_cb = lv_flush_done_cb,</span><br><span class="line">        .cb_param = &amp;disp_drv,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    st7789_driver_hw_init(&amp;st7789_config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cst816t_hw_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//初始化触摸硬件接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cst816t_cfg_t</span> cst816t_config = </span><br><span class="line">    &#123;</span><br><span class="line">        .scl = GPIO_NUM_10,</span><br><span class="line">        .sda = GPIO_NUM_11,</span><br><span class="line">        .fre = <span class="number">300</span>*<span class="number">1000</span>,</span><br><span class="line">        .x_limit = LCD_WIDTH,</span><br><span class="line">        .y_limit = LCD_HEIGHT,</span><br><span class="line">    &#125;;</span><br><span class="line">    cst816t_init(&amp;cst816t_config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_timer_cb</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> tick_interval = *((<span class="type">uint32_t</span>*)arg);</span><br><span class="line">    lv_tick_inc(tick_interval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_tick_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//初始化定时器</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> tick_interval = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">esp_timer_create_args_t</span> arg = </span><br><span class="line">    &#123;</span><br><span class="line">        .arg = &amp;tick_interval,</span><br><span class="line">        .callback = lv_timer_cb,<span class="comment">//回调函数</span></span><br><span class="line">        .name = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        .dispatch_method = ESP_TIMER_TASK,</span><br><span class="line">        .skip_unhandled_events = <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">esp_timer_handle_t</span> timer_handle;</span><br><span class="line">    esp_timer_create(&amp;arg,&amp;timer_handle);</span><br><span class="line">    esp_timer_start_periodic(timer_handle,tick_interval*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_port_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lv_init();</span><br><span class="line">    st7789_hw_init();</span><br><span class="line">    cst816t_hw_init();</span><br><span class="line">    lv_disp_init();</span><br><span class="line">    lv_indev_init();</span><br><span class="line">    lv_tick_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lv_port.h</strong></p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LV_PORT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LV_PORT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_port_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="修改ESP32配置文件"><a href="#修改ESP32配置文件" class="headerlink" title="修改ESP32配置文件"></a>修改ESP32配置文件</h2><p>在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py menuconfig</span><br></pre></td></tr></table></figure><ol><li><p>配置flash<br> Serial flasher configuration —&gt; Flash size —&gt; 8MB (32Mb)</p></li><li><p>打开psram<br>Component config —&gt; ESP PSRAM  </p></li><li><p>修改CUP频率<br>Component config —&gt; ESP32 System Settings —&gt; CPU frequency —&gt; 240MHz</p></li><li><p>配置LVGL<br>Component config —&gt; LVGL configuration —&gt; Color setings —&gt; Swap the 2 bytes of RGB565 color.<br>Component config —&gt; LVGL configuration —&gt; Memory settings —&gt; If ture use custom malloc&#x2F;free.&#x2F;&#x2F;将空间放置于psram中</p></li></ol><h1 id="ESP32基础外设"><a href="#ESP32基础外设" class="headerlink" title="ESP32基础外设"></a>ESP32基础外设</h1><h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><h1 id="ESP32开发小坑"><a href="#ESP32开发小坑" class="headerlink" title="ESP32开发小坑"></a>ESP32开发小坑</h1><h2 id="自带rtos延时函数不准问题"><a href="#自带rtos延时函数不准问题" class="headerlink" title="自带rtos延时函数不准问题"></a>自带rtos延时函数不准问题</h2><p> vTaskDelay();函数使用时，要想做到延时确定的时间，需要注意使用portTICK_PERIOD_MS宏进行tick时间转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vTaskDelay(<span class="number">1000</span>/portTICK_PERIOD_MS);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vTaskDelay(pdMS_TO_TICKS(<span class="number">500</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>新文章编写指南</title>
      <link href="/2024/11/18/%E6%96%B0%E6%96%87%E7%AB%A0%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/"/>
      <url>/2024/11/18/%E6%96%B0%E6%96%87%E7%AB%A0%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="兴建Hexo的Markdown博客文章"><a href="#兴建Hexo的Markdown博客文章" class="headerlink" title="兴建Hexo的Markdown博客文章"></a>兴建Hexo的Markdown博客文章</h1><p>在根文件夹打开 git bash 输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;文章名称&quot;</span></span><br></pre></td></tr></table></figure><p>注意必须要输入引号，否则会报错。在<code>\source\_posts</code>目录下会生成一个.md文件,文章可在该文件内编写。</p><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p>具体完整的内容可以查看<a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程</a> 本文章主要记录一些常用的Markdown语法。</p><h2 id="文案标题"><a href="#文案标题" class="headerlink" title="文案标题"></a>文案标题</h2><p>Markdown 标题有两种格式。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">一级标题</span></span><br><span class="line"><span class="section">=================</span></span><br><span class="line"></span><br><span class="line"><span class="section">二级标题</span></span><br><span class="line"><span class="section">-----------------</span></span><br></pre></td></tr></table></figure><p>该方法 <code>=</code> 和 <code>-</code> 的个数可以随意，但是不常用。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><p>该方法较为常用，但是要注意<code>#</code>的后面一定要加上空格<code> </code>否则语法不起作用。</p><h2 id="嵌入代码"><a href="#嵌入代码" class="headerlink" title="嵌入代码"></a>嵌入代码</h2><p>在文字段中加入编码可以使用两个符号“ &#96; ”来包裹，该符号位于键盘的 <kbd>esc</kbd> 键下面。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`printf(&quot;Hello World!&quot;)`</span></span><br></pre></td></tr></table></figure><p>Markdown效果：<code>printf(&quot;Hello World!&quot;)</code><br>当代码量相对较大时，可以使用两个<code>```</code>来包裹。第一个<code>```</code>后面可以加入语言名，如<code>C</code>，这样Markdown就会根据语言名高亮显示。编码如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\ <span class="code">```C</span></span><br><span class="line"><span class="code"> #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"> int main(int argc, char *argv[], char *envp[])</span></span><br><span class="line"><span class="code"> &#123;</span></span><br><span class="line"><span class="code">     printf(&quot;Hello World!\n&quot;);</span></span><br><span class="line"><span class="code">     return 0;</span></span><br><span class="line"><span class="code"> &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"> \```</span></span><br></pre></td></tr></table></figure><p>Markdown效果,可见语法已经被高亮显示了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h2><p>Markdown可以将链接嵌入文字中<code>[链接名称](链接地址)</code>，此时只显示链接中的链接名称，点击链接可以跳转到链接地址，举例如下。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">Fred&#x27;s Blog</span>](<span class="link">https://jasting10.github.io/</span>)</span><br></pre></td></tr></table></figure><p>效果如下:<a href="https://jasting10.github.io/">Fred’s Blog</a></p><p>当然也可以直接显示出需要跳转的链接，可以使用 <code>&lt;链接地址&gt;</code> 举例如下。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">&lt;https://jasting10.github.io/&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下:<a href="https://jasting10.github.io/">https://jasting10.github.io/</a></p><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>图片语法格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">alt 属性文本</span>](<span class="link">图片地址</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">alt 属性文本</span>](<span class="link">图片地址 &quot;可选标题&quot;</span>)</span><br></pre></td></tr></table></figure><p>可见该语法和嵌入链接的语法相似，举例如下。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">hummingbird.jpeg</span>](<span class="link">https://s2.loli.net/2024/11/14/s6jWuxrelG8Y52Z.jpg</span>)</span><br></pre></td></tr></table></figure><p>效果如下:<br><img src="https://s2.loli.net/2024/11/14/s6jWuxrelG8Y52Z.jpg" width="50%"><br>Markdown还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code>标签。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s2.loli.net/2024/11/14/s6jWuxrelG8Y52Z.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果如下,图像缩小长宽均50%:<br><img src="https://s2.loli.net/2024/11/14/s6jWuxrelG8Y52Z.jpg" width="25%"></p><h2 id="文字编辑"><a href="#文字编辑" class="headerlink" title="文字编辑"></a>文字编辑</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>Markdown 可以使用以下几种字体：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本*</span>**</span></span><br><span class="line"><span class="strong">__<span class="emphasis">_粗斜体文本_</span>__</span></span><br></pre></td></tr></table></figure><p>效果如下：<br><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线可以通过 HTML 的 <code>&lt;u&gt;</code> 标签来实现：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>带下划线文本<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果如下：<u>带下划线文本</u></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~BAIDU.COM~~</span><br></pre></td></tr></table></figure><p>效果如下：<del>BAIDU.COM</del></p><p><strong><strong>后续如用到新语法会继续更新文章</strong></strong></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
