<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ESP32学习笔记 | Fred's Blog</title><meta name="author" content="Fred"><meta name="copyright" content="Fred"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="ESP32开发相关链接开发ESP32可以采用IDF和Arduino IDE进行开发。为了进一步学习LVGL图形库和FreeRTOS，我选择使用乐鑫IDF进行开发。IDT开发官方文档可见快速入门 一些idf常用命令idf工具主要调用idf.py这个python脚本，通过传递不同的参数实现不同功能，如交叉编译等。为了终端可以调用该指令需要将其添加路径到系统环境变量中,Linux系统下在目录下运行she">
<meta property="og:type" content="article">
<meta property="og:title" content="ESP32学习笔记">
<meta property="og:url" content="https://jasting10.github.io/2024/11/24/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Fred&#39;s Blog">
<meta property="og:description" content="ESP32开发相关链接开发ESP32可以采用IDF和Arduino IDE进行开发。为了进一步学习LVGL图形库和FreeRTOS，我选择使用乐鑫IDF进行开发。IDT开发官方文档可见快速入门 一些idf常用命令idf工具主要调用idf.py这个python脚本，通过传递不同的参数实现不同功能，如交叉编译等。为了终端可以调用该指令需要将其添加路径到系统环境变量中,Linux系统下在目录下运行she">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/11/14/c36iWANzL9mxSGV.png">
<meta property="article:published_time" content="2024-11-24T05:07:10.000Z">
<meta property="article:modified_time" content="2024-11-27T05:25:03.959Z">
<meta property="article:author" content="Fred">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/11/14/c36iWANzL9mxSGV.png"><link rel="shortcut icon" href="https://s2.loli.net/2024/11/21/iUxLrp9JsawYOEV.png"><link rel="canonical" href="https://jasting10.github.io/2024/11/24/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ESP32学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-27 13:25:03'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2024/11/14/c36iWANzL9mxSGV.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 相关链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="Fred's Blog"><span class="site-name">Fred's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 相关链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ESP32学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-24T05:07:10.000Z" title="发表于 2024-11-24 13:07:10">2024-11-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-27T05:25:03.959Z" title="更新于 2024-11-27 13:25:03">2024-11-27</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="ESP32开发相关链接"><a href="#ESP32开发相关链接" class="headerlink" title="ESP32开发相关链接"></a>ESP32开发相关链接</h1><p>开发ESP32可以采用IDF和Arduino IDE进行开发。为了进一步学习LVGL图形库和FreeRTOS，我选择使用乐鑫IDF进行开发。IDT开发官方文档可见<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.3/esp32/get-started/index.html#id2">快速入门</a></p>
<h1 id="一些idf常用命令"><a href="#一些idf常用命令" class="headerlink" title="一些idf常用命令"></a>一些idf常用命令</h1><p>idf工具主要调用<code>idf.py</code>这个python脚本，通过传递不同的参数实现不同功能，如交叉编译等。为了终端可以调用该指令需要将其添加路径到系统环境变量中,Linux系统下在目录下运行shell脚本<code>$ ./source export.sh</code>即可自动添加系统环境变量。</p>
<h2 id="创建一个空工程"><a href="#创建一个空工程" class="headerlink" title="创建一个空工程"></a>创建一个空工程</h2><p>其中my_project为自定义工程名，该命令会创建一个空工程，并生成工程文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py create-project my_project</span><br></pre></td></tr></table></figure>
<h2 id="设置芯片类型"><a href="#设置芯片类型" class="headerlink" title="设置芯片类型"></a>设置芯片类型</h2><ul>
<li>ESP32系列模组：idf.py set-target esp32</li>
<li>ESP32-S2系列模组：idf.py set-target esp32s2</li>
<li>ESP32-C3系列模组：idf.py set-target esp32c3</li>
<li>ESP32-S3系列模组：idf.py set-target esp32s3</li>
</ul>
<p>这里我们以ESP32-S3系列模组为例，在终端内运行命令行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py set-target ESP32s3</span><br></pre></td></tr></table></figure>
<p>idf自动切换为S3型号。</p>
<h2 id="构建-清除工程"><a href="#构建-清除工程" class="headerlink" title="构建&amp;清除工程"></a>构建&amp;清除工程</h2><p>构建指令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py build</span><br></pre></td></tr></table></figure>
<p>由于芯片具有一定复杂度，编译中产生大量中间文件，编译后工程内存占用高达百兆不利于传递存储。清除编译中间文件指令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py clean</span><br></pre></td></tr></table></figure>
<h2 id="下载-调试工程"><a href="#下载-调试工程" class="headerlink" title="下载&amp;调试工程"></a>下载&amp;调试工程</h2><p>下载指令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py flash</span><br></pre></td></tr></table></figure>
<p>可以使用下面指令监视串口输出，PORT为串口设备，如&#x2F;dev&#x2F;ttyUSB0。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py -p PORT monitor</span><br></pre></td></tr></table></figure>
<p>也可以直接调试工程，使用下面指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ idf.py monitor</span><br></pre></td></tr></table></figure>
<p><span style="color: red;">特别注意Linux终端退出需要按<kbd>Ctrl</kbd>+<kbd>[</kbd>, 其他什么都不好使。</span></p>
<h1 id="FreeRTOS基础"><a href="#FreeRTOS基础" class="headerlink" title="FreeRTOS基础"></a>FreeRTOS基础</h1><p>由于ESP32的芯片具有多核特性(如ESP32s3为基于Tensilica Xtensa LX6架构双核芯片)，主核和协处理器分别采用240MHz和160MHz的频率。为了更好的分配任务，所以IDF使用FreeRTOS操作系统进行多线程编程。<br><strong>一个任务可以为以下几种状态</strong>:</p>
<ul>
<li><strong>运行(Running)</strong> ：如果处理器为单核，同一时刻只有一个任务被执行。</li>
<li><strong>准备状态</strong> ：任务处于能够执行但是没有执行的状态，原因为操作系统在执行一些高优先级的任务。</li>
<li><strong>阻塞(Blocked)</strong> ：任务正在等待时间或者外部事件，如调用<code>vTaskDelay()</code>延时。任务也可以通过阻塞来等待队列、信号量、事件组、通知或信号量事件。处于阻塞状态的任务通常有一个”超时”期， 超时后任务将被超时，并被解除阻塞。</li>
<li><strong>挂起(Suspended)</strong> ：与“阻塞”状态下的任务一样， “挂起”状态下的任务不能 被选择进入运行状态，但处于挂起状态的任务没有超时。相反，任务只有在分别通过 <code>vTaskSuspend()</code> 和 <code>xTaskResume()</code>API 调用明确命令时 才会进入或退出挂起状态。</li>
</ul>
<p><strong>任务优先级</strong>：每个任务均被分配了从 0 到 ( <code>configMAX_PRIORITIES - 1</code> ) 的优先级，其中的<code>configMAX_PRIORITIES</code> 在 <code>FreeRTOSConfig.h</code> 中定义，<span style="color: red;">低优先级数字表示低优先级任务,数字越大任务优先级越高,空闲任务的优先级为零。</span></p>
<h2 id="FreeRTOS创建任务"><a href="#FreeRTOS创建任务" class="headerlink" title="FreeRTOS创建任务"></a>FreeRTOS创建任务</h2><p>如下是创建一个乐鑫官方移植的任务创建函数<code>xTaskCreatePinnedToCor</code>(<span style="color: red;">推荐使用</span>)它有7个参数，参数为任务函数指针、任务名称、堆栈大小、任务参数、优先级、任务句柄、内核号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreatePinnedToCore</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pvTaskCode, <span class="comment">//任务函数指针，原型是 void fun(void *param)</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *constpcName, <span class="comment">//任务的名称，打印调试可能会有用</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> usStackDepth,<span class="comment">//指定的任务堆栈空间大小（字节）</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> *constpvParameters, <span class="comment">//任务参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority, <span class="comment">// 优先级，数字越大，优先级越大0到(configMAX_PRIORITIES - 1)</span></span></span><br><span class="line"><span class="params">    TaskHandle_t *constpvCreatedTask, <span class="comment">//传回来的任务句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> BaseType_t xCoreID)</span> <span class="comment">//分配在哪个内核上运行</span></span><br></pre></td></tr></table></figure>
<p>如果任务创建成功则返回pdPASS，否则返回pdFAIL。<br>创建函数还可以是<code>xTaskCreate</code>(内部还是使用了<code>xTaskCreatePinnedToCore</code>但是会自动分配内核)函数及参数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,<span class="comment">//指向任务函数的指针。</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,<span class="comment">//任务的名称（用于调试）。</span></span></span><br><span class="line"><span class="params">    configSTACK_DEPTH_TYPE usStackDepth,<span class="comment">//任务堆栈的深度（以堆栈项为单位）。</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * pvParameters,<span class="comment">//传递给任务函数的参数。</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,<span class="comment">//任务的优先级</span></span></span><br><span class="line"><span class="params">    TaskHandle_t * pxCreatedTask<span class="comment">//用于存储创建的任务句柄的指针（可以为 NULL）。</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="直接创建任务和静态任务的区别"><a href="#直接创建任务和静态任务的区别" class="headerlink" title="直接创建任务和静态任务的区别"></a>直接创建任务和静态任务的区别</h3><p>在FreeRTOS中，直接创建任务（通常指的是使用<code>xTaskCreate</code>函数动态创建任务）和创建静态任务（使用<code>xTaskCreateStatic</code>函数）之间存在几个关键区别。以下是对这两者的详细比较：<br><strong>1. 内存分配方式</strong></p>
<ul>
<li><strong>直接创建任务（动态创建）</strong>：内存是在运行时通过动态内存分配函数（如<code>pvPortMalloc</code>）来分配的。创建任务时，不需要预先定义和初始化额外的变量来存储任务信息。任务的相关信息直接存储在动态分配的内存中。动态创建任务的内存空间可以在任务完成后释放，因此可以在运行时动态地创建和删除任务。</li>
<li><strong>创建静态任务</strong>：内存是在编译时分配的，需要定义并初始化一个<code>StaticTask_t</code>类型的变量来存储任务的相关信息。静态创建任务的内存空间在任务整个运行期间都被任务所占用，直到任务被删除。静态创建任务通常在应用程序的启动阶段进行，<span style="color: red;">任务的数量是固定的，无法在运行时动态调整。</span><br><strong>2. 内存管理</strong></li>
<li><strong>直接创建任务</strong>：由于内存是动态分配的，因此需要在任务完成后手动释放内存（尽管FreeRTOS本身可能并不直接提供释放任务内存的API，但可以通过删除任务来间接释放内存）。动态内存分配可能增加内存碎片化的风险。</li>
<li><strong>创建静态任务</strong>：内存是静态分配的，因此不需要担心内存碎片化和手动释放内存的问题。但由于内存是在编译时分配的，因此需要预先知道任务所需的内存大小。<br><strong>3. 灵活性</strong></li>
<li><strong>直接创建任务</strong>：提供了更高的灵活性，因为可以在运行时根据需要动态地创建和删除任务。适用于任务数量可能会根据系统状态或用户交互而动态变化的应用场景。</li>
<li><strong>创建静态任务</strong>：灵活性较低，因为任务的数量和内存大小在编译时就已确定。但由于内存是静态分配的，因此可以提供更稳定的内存使用模式，并减少运行时内存分配的开销。<br><strong>1. 使用场景</strong></li>
<li><strong>直接创建任务</strong>： 适用于需要动态调整任务数量和类型的系统，如事件驱动系统、多协议通信系统或并行处理系统。</li>
<li><strong>创建静态任务</strong>：适用于任务数量和类型在编译时就已确定的系统，或对内存使用有严格要求的应用场景。</li>
</ul>
<h3 id="创建静态任务的函数"><a href="#创建静态任务的函数" class="headerlink" title="创建静态任务的函数"></a>创建静态任务的函数</h3><p>乐鑫官方移植的FreeRTOS提供了创建静态任务的函数<code>xTaskCreateStaticPinnedToCore</code>，它需要用户提前分配好任务栈和任务控制块的内存，然后调用该函数创建静态任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreateStaticPinnedToCore</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,      <span class="comment">// 指向任务函数的指针，任务函数是任务执行的具体逻辑</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,      <span class="comment">// 任务的名称，用于调试和识别任务</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth,    <span class="comment">// 任务堆栈的大小，以字为单位（通常是4字节）</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * pvParameters,            <span class="comment">// 传递给任务函数的参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,         <span class="comment">// 任务的优先级，优先级较高的任务会优先执行</span></span></span><br><span class="line"><span class="params">    StackType_t * pxStackBuffer,    <span class="comment">// 指向任务堆栈缓冲区的指针，缓冲区必须由调用者分配</span></span></span><br><span class="line"><span class="params">    StaticTask_t * pxStaticTaskBuffer, <span class="comment">// 指向静态任务控制块（TCB）的指针，结构体用于存储任务的相关信息，必须由调用者分配</span></span></span><br><span class="line"><span class="params">    BaseType_t xCoreID              <span class="comment">// 指定任务运行的 CPU 核心 ID，0 或 1</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>FreeRTOS的创建函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreateStatic</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,      <span class="comment">// 指向任务函数的指针，任务函数是任务执行的具体逻辑</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,      <span class="comment">// 任务的名称，用于调试和识别任务</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth,    <span class="comment">// 任务堆栈的大小，以字为单位（通常是4字节）</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * pvParameters,            <span class="comment">// 传递给任务函数的参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,         <span class="comment">// 任务的优先级，优先级较高的任务会优先执行</span></span></span><br><span class="line"><span class="params">    StackType_t * pxStackBuffer,    <span class="comment">// 指向任务堆栈缓冲区的指针，缓冲区必须由调用者分配</span></span></span><br><span class="line"><span class="params">    StaticTask_t * pxStaticTaskBuffer <span class="comment">// 指向静态任务控制块（TCB）的指针，结构体用于存储任务的相关信息，必须由调用者分配</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="FreeRTOS任务创建案例"><a href="#FreeRTOS任务创建案例" class="headerlink" title="FreeRTOS任务创建案例"></a>FreeRTOS任务创建案例</h3><p>如下创建两个任务并打印相关的数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span><span class="comment">//只要使用FreeRTOS就需要包含该文件，</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span><span class="comment">//创建任务有关的函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span><span class="comment">//用于调试的功能，通过串口打印数据</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*任务A函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskA</span><span class="params">(<span class="type">void</span>* param)</span> <span class="comment">//void*是一种特殊的指针类型，被称为“无类型指针”或“通用指针”。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">100</span>) i++;</span><br><span class="line">        <span class="keyword">else</span> i = <span class="number">0</span>;</span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TaskA&quot;</span>,<span class="string">&quot;Timer_%d&quot;</span>,i);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">500</span>));<span class="comment">//pdMS_TO_TICKS(500)将系统节拍转换成具体时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*任务B函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskB</span><span class="params">(<span class="type">void</span>* param)</span> <span class="comment">//void*是一种特殊的指针类型，被称为“无类型指针”或“通用指针”。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">100</span>) i++;</span><br><span class="line">        <span class="keyword">else</span> i = <span class="number">0</span>;</span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TaskB&quot;</span>,<span class="string">&quot;Timer_%d&quot;</span>,i);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">2000</span>));<span class="comment">//pdMS_TO_TICKS(500)将系统节拍转换成具体时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    xTaskCreatePinnedToCore(TaskA, <span class="string">&quot;TaskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">1</span>);<span class="comment">//栈空间最小2048</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskB, <span class="string">&quot;TaskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">1</span>);<span class="comment">//栈空间最小2048</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="FreeRTOS任务阻塞延时"><a href="#FreeRTOS任务阻塞延时" class="headerlink" title="FreeRTOS任务阻塞延时"></a>FreeRTOS任务阻塞延时</h2><p>FreeRTOS提供了两种阻塞延时函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延时 xTicksToDelay 个周期</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">( <span class="type">const</span> TickType_t xTicksToDelay )</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelayUntil</span><span class="params">( <span class="type">const</span> TickType_t *pxPreviousWakeTime, <span class="type">const</span> TickType_t xTimeIncrement )</span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：<code>const TickType_t *pxPreviousWakeTime</code>: 指向上次任务唤醒时间的指针。这个变量应该在第一次调用 vTaskDelayUntil 之前初始化为当前时间。<code>const TickType_t xTimeIncrement</code>: 任务每次执行之间的时间间隔，以滴答数（<code>ticks</code>）为单位。<br><strong>使用步骤</strong>：初始化 <code>pxPreviousWakeTime</code>: 在任务第一次执行时，需要初始化 <code>pxPreviousWakeTime</code> 为当前时间。调用 <code>vTaskDelayUntil</code>: 在每次任务执行结束时，调用<code>vTaskDelayUntil</code>函数，传入<code>pxPreviousWakeTime</code>和<code>xTimeIncrement</code>。<br>示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义任务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPeriodicTask</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    TickType_t xLastWakeTime;</span><br><span class="line">    <span class="type">const</span> TickType_t xFrequency = <span class="number">1000</span> / portTICK_PERIOD_MS; <span class="comment">// 1000 ms (1 second)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 xLastWakeTime 为当前时间</span></span><br><span class="line">    xLastWakeTime = xTaskGetTickCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 任务执行的逻辑</span></span><br><span class="line">        <span class="comment">// 例如：打印一条消息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Task is running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延迟直到下次唤醒时间</span></span><br><span class="line">        vTaskDelayUntil(&amp;xLastWakeTime, xFrequency);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="FreeRTOS任务同步"><a href="#FreeRTOS任务同步" class="headerlink" title="FreeRTOS任务同步"></a>FreeRTOS任务同步</h2><p><strong>RTOS中的同步</strong> ：是指是不同任务之间或者任务与外部事件之间的协同工作方式,确保多个并发执行的任务按照预期的顺序或时机执行。它涉及到线程或任务间的通信和协调机制，目的是为了<span style="color: red;">避免数据竞争、解决竞态条件</span>,并确保系统的正确行为。<br><strong>互斥</strong> ：某一资源同时只允许一个线程或任务访问，其他线程或任务必须等待。<span style="color: red;">具有唯一性和排他性</span>。</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是任务间通信的主要形式。 它们可以用于在任务之间以及中断和任务之间发送消息。 在大多数情况下，它们作为线程安全的 FIFO（先进先出）缓冲区使用，新数据被发送到队列的后面， 尽管数据也可以发送到前面。<span style="color: red;">尾部进入，头部读出</span><br><code>QueueHandle_t</code>为队列的句柄类型，本质上是一个指针。常用API函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t <span class="title function_">xQueueCreate</span><span class="params">( <span class="comment">//创建一个队列，成功返回队列句柄</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxQueueLength, <span class="comment">//队列容量</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxItemSize <span class="comment">//每个队列项所占内存的大小（单位是字节）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSend</span><span class="params">( <span class="comment">//向队列头部发送一个消息</span></span></span><br><span class="line"><span class="params">    QueueHandle_t xQueue, <span class="comment">// 队列句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> * pvItemToQueue, <span class="comment">//要发送的消息指针</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSendToBack</span><span class="params">( <span class="comment">//向队列尾部发送一个消息</span></span></span><br><span class="line"><span class="params">    QueueHandle_t xQueue, <span class="comment">// 队列句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> * pvItemToQueue, <span class="comment">//要发送的消息指针</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueReceive</span><span class="params">( <span class="comment">//从队列接收一条消息</span></span></span><br><span class="line"><span class="params">    QueueHandle_t xQueue, <span class="comment">//队列句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * pvBuffer, <span class="comment">//指向接收消息缓冲区的指针。</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSendFromISR</span><span class="params">( <span class="comment">//xQueueSend 的中断版本</span></span></span><br><span class="line"><span class="params">    QueueHandle_t xQueue, <span class="comment">// 队列句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> * pvItemToQueue, <span class="comment">//要发送的消息指针</span></span></span><br><span class="line"><span class="params">    BaseType_t *pxHigherPriorityTaskWoken )</span>; <span class="comment">//指出是否有高优先级的任务被唤醒</span></span><br></pre></td></tr></table></figure>
<p><strong>队列使用案例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">QueueHandle_t my_queue = <span class="literal">NULL</span>;<span class="comment">//创建队列指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> <span class="comment">//定义一个数据类型</span></span><br><span class="line">    <span class="type">int</span> vslue;</span><br><span class="line">    <span class="type">int</span> Num;</span><br><span class="line">&#125;QueueData;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskA</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//创建任务A，向队列中发送数据</span></span><br><span class="line">&#123;</span><br><span class="line">    QueueData Temp;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;Temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(QueueData));<span class="comment">//初始化结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Temp.Num++;</span><br><span class="line">        Temp.vslue+=<span class="number">2</span>;</span><br><span class="line">        xQueueSend(my_queue, &amp;Temp, <span class="number">100</span>);<span class="comment">//向队列中发送数据</span></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskB</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//创建任务B，从队列中接收数据</span></span><br><span class="line">&#123;</span><br><span class="line">    QueueData Temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pdTRUE == xQueueReceive(my_queue, &amp;Temp, <span class="number">100</span>))<span class="comment">//从队列中接收数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(<span class="string">&quot;TaskB_Receive&quot;</span>, <span class="string">&quot;Value = %d, Num = %d。&quot;</span>,Temp.vslue, Temp.Num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    my_queue = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(QueueData));<span class="comment">//初始化队列</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskA, <span class="string">&quot;TaskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">1</span>);<span class="comment">//创建任务</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskB, <span class="string">&quot;TaskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">3</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是用来保护共享资源不会被多个任务并发使用。信号量使用起来比较简单。因为在 freeRTOS 中它本质上就是队列，只不过<span style="color: red;">信号量只关心队列中的数量而不关心队列中的消息内容</span>，在 freeRTOS 中有两种常用的信号量，一是计数信号量，而是二进制信号量。</p>
<ul>
<li>二进制信号量很简单，就是信号量总数只有 1，也就是这个图中总雨伞数量只有 1。</li>
<li>计数信号量则可以自定义总共的信号量</li>
</ul>
<p>信号量的句柄<code>SemaphoreHandle_t</code>,常用API函数如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建二值信号量，成功则返回信号量句柄（二值信号量最大只有 1 个）</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinary</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建计数信号量，成功则返回信号量句柄</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">(</span></span><br><span class="line"><span class="params">    UBaseType_t uxMaxCount, <span class="comment">//最大信号量数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxInitialCount)</span>; <span class="comment">//初始信号量数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个信号量，如果获得信号量，则返回 pdTRUE</span></span><br><span class="line">xSemaphoreTake( </span><br><span class="line">    SemaphoreHandle_t xSemaphore,<span class="comment">//信号量句柄</span></span><br><span class="line">    TickType_t xTicksToWait ); <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放一个信号量，及放回信号量，成功返回 pdTRUE</span></span><br><span class="line">xSemaphoreGive( SemaphoreHandle_t xSemaphore ); <span class="comment">//信号量句柄</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除信号量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/semphr.h&quot;</span><span class="comment">//信号量有关函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SemaphoreHandle_t My_sem;<span class="comment">//定义信号量的句柄</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskA</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//任务A负责发送信号量</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">        xSemaphoreGive(My_sem); <span class="comment">//信号量句柄</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskB</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//任务B接受到信号量之后打印标记</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pdTRUE == xSemaphoreTake(My_sem, <span class="number">100</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(<span class="string">&quot;TaskB&quot;</span>, <span class="string">&quot;sem is OK&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    My_sem = xSemaphoreCreateBinary();<span class="comment">//初始化句柄</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskA, <span class="string">&quot;TaskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(TaskB, <span class="string">&quot;TaskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁：与二进制信号量类似，但会发生优先级翻转。保证优先级一致性。<br>互斥锁的句柄<code>SemaphoreHandle_t</code>和信号量一样，常用API函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个互斥锁</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutex</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥量获取函数，成功则返回 pdTRUE</span></span><br><span class="line">xSemaphoreTake( </span><br><span class="line">    SemaphoreHandle_t xSemaphore,<span class="comment">//互斥锁句柄</span></span><br><span class="line">    TickType_t xTicksToWait ); <span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure>
<p>获取函数的<code>TickType_t xTicksToWait</code>最好填写<code>portMAX_DELAY</code>无限延时，这样当任务A获取互斥锁后，任务B就无法获取锁了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥量释放函数 </span></span><br><span class="line">xSemaphoreGive( SemaphoreHandle_t xSemaphore ); <span class="comment">//互斥锁句柄</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除互斥锁</span></span><br><span class="line">vSemaphoreDelete( SemaphoreHandle_t xSemaphore );</span><br></pre></td></tr></table></figure>
<p><strong>示例代码如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/semphr.h&quot;</span><span class="comment">//互斥锁有关函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SemaphoreHandle_t My_Mutex;<span class="comment">//定义互斥锁的句柄</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskA</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//任务A负责发送信号量</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xSemaphoreTake(My_Mutex, portMAX_DELAY);<span class="comment">//获取互斥锁  //</span></span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TaskA&quot;</span>, <span class="string">&quot;Mutex is OK&quot;</span>);                    <span class="comment">//互斥锁保护区域</span></span><br><span class="line">        xSemaphoreGive(My_Mutex); <span class="comment">//释放互斥锁                //</span></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">2000</span>));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskB</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//任务B接受到信号量之后打印标记</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xSemaphoreTake(My_Mutex, portMAX_DELAY);<span class="comment">//获取互斥锁  //</span></span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TaskB&quot;</span>, <span class="string">&quot;Mutex is OK&quot;</span>);                    <span class="comment">//互斥锁保护区域</span></span><br><span class="line">        xSemaphoreGive(My_Mutex); <span class="comment">//释放互斥锁                //</span></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    My_Mutex = xSemaphoreCreateMutex();<span class="comment">//初始化互斥锁句柄</span></span><br><span class="line">    xTaskCreatePinnedToCore(TaskA, <span class="string">&quot;TaskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(TaskB, <span class="string">&quot;TaskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FreeRTOS事件组"><a href="#FreeRTOS事件组" class="headerlink" title="FreeRTOS事件组"></a>FreeRTOS事件组</h3><p><strong>事件位</strong>：用于指示事件是否发生，事件位通常称为事件标志。<br><strong>事件组</strong>：就是一组事件位，事件组中的事件位通过位编号来引用。<br>下图表示一个 24 位事件组， 使用 3 个位来保存前面描述的 3 个示例事件<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a5501132ff95ddc8f2d6aef123035ecb.png" alt="EventGroup"><br>接收事件时，可以根据感兴趣的参事件类型接收事件的单个或者多个事件类型。事件接收成功后，必须使用<code>xClearOnExit</code>选项来清除已接收到的事件类型，否则不会清除已接收 到的 事件 ，这样就需要用户显式清除事位。<br>函数句柄<code>EventGroupHandle_t</code>,相关API函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个事件组，返回事件组句柄，失败返回 NULL</span></span><br><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreate</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待事件组中某个标志位,用返回值以确定哪些位已完成设置</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupWaitBits</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">const</span> EventGroupHandle_t xEventGroup, <span class="comment">//事件组句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> EventBits_t uxBitsToWaitFor, <span class="comment">//哪些位需要等待</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> BaseType_t xClearOnExit, <span class="comment">//是否读取完成后自动清除标志位</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> BaseType_t xWaitForAllBits, <span class="comment">//是否等待的标志位都成功了才返回</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//最大阻塞时间</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置标志位</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupSetBits</span><span class="params">(</span></span><br><span class="line"><span class="params">    EventGroupHandle_t xEventGroup,<span class="comment">//事件组句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> EventBits_t uxBitsToSet )</span>; <span class="comment">//设置哪个位</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清除标志位</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupClearBits</span><span class="params">(</span></span><br><span class="line"><span class="params">    EventGroupHandle_t xEventGroup, <span class="comment">//事件组句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> EventBits_t uxBitsToClear )</span>; <span class="comment">//清除的标志位</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// xEventGroup: 事件组句柄，你要删除哪个事件组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vEventGroupDelete</span><span class="params">( EventGroupHandle_t xEventGroup )</span></span><br></pre></td></tr></table></figure>
<p><strong>示例代码如下</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/event_groups.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> EventGroupHandle_t s_testEvent;<span class="comment">//事件组句柄</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_taskA</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//事件任务A，用于定时标记事件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xEventGroupSetBits(s_testEvent,BIT0);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">        xEventGroupSetBits(s_testEvent,BIT1);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">event_taskB</span><span class="params">(<span class="type">void</span>* param)</span><span class="comment">//事件任务B，等待事件组中BIT0和BIT1位</span></span><br><span class="line">&#123;</span><br><span class="line">    EventBits_t ev;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ev = xEventGroupWaitBits(s_testEvent,BIT0|BIT1,pdTRUE,pdFALSE,portMAX_DELAY);</span><br><span class="line">        <span class="keyword">if</span>(ev &amp; BIT0)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG,<span class="string">&quot;Event BIT0 set&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ev&amp; BIT1)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG,<span class="string">&quot;Event BIT1 set&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rtos_event_sample</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//事件例程初始化</span></span><br><span class="line">&#123;</span><br><span class="line">    s_testEvent = xEventGroupCreate();</span><br><span class="line">    xTaskCreatePinnedToCore(event_taskA,<span class="string">&quot;event_taskA&quot;</span>,<span class="number">2048</span>,<span class="literal">NULL</span>,<span class="number">3</span>,<span class="literal">NULL</span>,<span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(event_taskB,<span class="string">&quot;event_taskB&quot;</span>,<span class="number">2048</span>,<span class="literal">NULL</span>,<span class="number">3</span>,<span class="literal">NULL</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="直达任务通知"><a href="#直达任务通知" class="headerlink" title="直达任务通知"></a>直达任务通知</h3><p><strong>定义</strong>：每个 RTOS 任务都有一个任务通知数组。 每条任务通知 都有“挂起”或“非挂起”的通知状态， 以及一个 32 位通知值。直达任务通知是直接发送至任务的事件，而不是通过中间对象 （如队列、事件组或信号量）间接发送至任务的事件。向任务发送“直达任务通知” 会将目标任务通知设为“挂起”状态（此挂起不是挂起任务）。<br><strong>API常用函数如下</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于将事件直接发送到 RTOS 任务并可能取消该任务的阻塞状态</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotify</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskHandle_t xTaskToNotify, <span class="comment">//要通知的任务句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> ulValue, <span class="comment">//携带的通知值</span></span></span><br><span class="line"><span class="params">    eNotifyAction eAction )</span>; <span class="comment">//执行的操作</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是参数 eAction 如下表所述:</p>
<table>
<thead>
<tr>
<th align="center">eAction 设置</th>
<th align="center">执行的操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">eNoAction</td>
<td align="center">目标任务接收事件，但其 通知值未更新。 在这种情况下，不使用 ulValue。</td>
</tr>
<tr>
<td align="center">eSetBits</td>
<td align="center">目标任务的通知值 使用 ulValue 按位或运算</td>
</tr>
<tr>
<td align="center">eIncrement</td>
<td align="center">目标任务的通知值自增 1（类似信号量的 give 操作）</td>
</tr>
<tr>
<td align="center">eSetValueWithOverwrite</td>
<td align="center">目标任务的通知值 无条件设置为 ulValue。</td>
</tr>
<tr>
<td align="center">eSetValueWithoutOrwrite</td>
<td align="center">如果目标任务没有 挂起的通知，则其通知值 将设置为 ulValue。如果目标任务已经有 挂起的通知，则不会更新其通知值。</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待接收任务通知</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyWait</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> ulBitsToClearOnEntry, <span class="comment">//进入函数清除的通知值位</span></span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> ulBitsToClearOnExit,<span class="comment">//退出函数清除的通知值位</span></span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> *pulNotificationValue, <span class="comment">//通知值</span></span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait )</span>; <span class="comment">//等待时长</span></span><br></pre></td></tr></table></figure>
<p><strong>示例代码如下</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/event_groups.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要使用任务通知，需要记录任务句柄</span></span><br><span class="line"><span class="type">static</span> TaskHandle_t s_notifyTaskAHandle;</span><br><span class="line"><span class="type">static</span> TaskHandle_t s_notifyTaskBHandle;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 任务通知A，用于定时向任务通知B直接传输数据</span></span><br><span class="line"><span class="comment"> * @param 无</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">notify_taskA</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> rec_val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (xTaskNotifyWait(<span class="number">0x00</span>, ULONG_MAX, &amp;rec_val, pdMS_TO_TICKS(<span class="number">1000</span>)) == pdTRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG,<span class="string">&quot;receive notify value:%lu&quot;</span>,rec_val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 任务通知B，实时接收任务通知A的数据</span></span><br><span class="line"><span class="comment"> * @param 无</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">notify_taskB</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> notify_val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xTaskNotify(s_notifyTaskAHandle, notify_val, eSetValueWithOverwrite);</span><br><span class="line">        notify_val++;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 任务通知例程初始化</span></span><br><span class="line"><span class="comment"> * @param 无</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtos_notify_sample</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    xTaskCreatePinnedToCore(notify_taskA,<span class="string">&quot;notify_taskA&quot;</span>,<span class="number">2048</span>,<span class="literal">NULL</span>,<span class="number">3</span>,&amp;s_notifyTaskAHandle,<span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(notify_taskB,<span class="string">&quot;notify_taskB&quot;</span>,<span class="number">2048</span>,<span class="literal">NULL</span>,<span class="number">3</span>,&amp;s_notifyTaskBHandle,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="ESP32基础外设"><a href="#ESP32基础外设" class="headerlink" title="ESP32基础外设"></a>ESP32基础外设</h1><h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><h1 id="ESP32开发小坑"><a href="#ESP32开发小坑" class="headerlink" title="ESP32开发小坑"></a>ESP32开发小坑</h1><h2 id="自带rtos延时函数不准问题"><a href="#自带rtos延时函数不准问题" class="headerlink" title="自带rtos延时函数不准问题"></a>自带rtos延时函数不准问题</h2><p> vTaskDelay();函数使用时，要想做到延时确定的时间，需要注意使用portTICK_PERIOD_MS宏进行tick时间转换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vTaskDelay(<span class="number">1000</span>/portTICK_PERIOD_MS);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vTaskDelay(pdMS_TO_TICKS(<span class="number">500</span>));</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2024/11/14/c36iWANzL9mxSGV.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/11/18/%E6%96%B0%E6%96%87%E7%AB%A0%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/" title="新文章编写指南"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">新文章编写指南</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2024/11/14/c36iWANzL9mxSGV.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Fred</div><div class="author-info__description">个人知识存储，作品发布</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Jasting10"><i class="fab fa-github"></i><span>Github主页</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ESP32%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5"><span class="toc-number">1.</span> <span class="toc-text">ESP32开发相关链接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9Bidf%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">一些idf常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%A9%BA%E5%B7%A5%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">创建一个空工程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%8A%AF%E7%89%87%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">设置芯片类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-%E6%B8%85%E9%99%A4%E5%B7%A5%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">构建&amp;清除工程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD-%E8%B0%83%E8%AF%95%E5%B7%A5%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">下载&amp;调试工程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FreeRTOS%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">FreeRTOS基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FreeRTOS%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.1.</span> <span class="toc-text">FreeRTOS创建任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.1.</span> <span class="toc-text">直接创建任务和静态任务的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">创建静态任务的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FreeRTOS%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E6%A1%88%E4%BE%8B"><span class="toc-number">3.1.3.</span> <span class="toc-text">FreeRTOS任务创建案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FreeRTOS%E4%BB%BB%E5%8A%A1%E9%98%BB%E5%A1%9E%E5%BB%B6%E6%97%B6"><span class="toc-number">3.2.</span> <span class="toc-text">FreeRTOS任务阻塞延时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FreeRTOS%E4%BB%BB%E5%8A%A1%E5%90%8C%E6%AD%A5"><span class="toc-number">3.3.</span> <span class="toc-text">FreeRTOS任务同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">3.3.1.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">3.3.2.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">3.3.3.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FreeRTOS%E4%BA%8B%E4%BB%B6%E7%BB%84"><span class="toc-number">3.3.4.</span> <span class="toc-text">FreeRTOS事件组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E8%BE%BE%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5"><span class="toc-number">3.3.5.</span> <span class="toc-text">直达任务通知</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ESP32%E5%9F%BA%E7%A1%80%E5%A4%96%E8%AE%BE"><span class="toc-number">4.</span> <span class="toc-text">ESP32基础外设</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO"><span class="toc-number">4.1.</span> <span class="toc-text">GPIO</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ESP32%E5%BC%80%E5%8F%91%E5%B0%8F%E5%9D%91"><span class="toc-number">5.</span> <span class="toc-text">ESP32开发小坑</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%B8%A6rtos%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%E4%B8%8D%E5%87%86%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">自带rtos延时函数不准问题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/24/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="ESP32学习笔记">ESP32学习笔记</a><time datetime="2024-11-24T05:07:10.000Z" title="发表于 2024-11-24 13:07:10">2024-11-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/18/%E6%96%B0%E6%96%87%E7%AB%A0%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/" title="新文章编写指南">新文章编写指南</a><time datetime="2024-11-18T12:30:00.000Z" title="发表于 2024-11-18 20:30:00">2024-11-18</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2024 By Fred</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>